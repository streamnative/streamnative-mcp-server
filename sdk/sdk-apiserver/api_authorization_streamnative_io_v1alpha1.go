// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

/*
Api

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sncloud

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// AuthorizationStreamnativeIoV1alpha1ApiService AuthorizationStreamnativeIoV1alpha1Api service
type AuthorizationStreamnativeIoV1alpha1ApiService service

type ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount) ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Pretty(pretty string) ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) DryRun(dryRun string) ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) FieldManager(fieldManager string) ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	return r.ApiService.CreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountExecute(r)
}

/*
CreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount Method for CreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount

create an IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount(ctx context.Context, namespace string) ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	return ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountExecute(r ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.CreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/namespaces/{namespace}/iamaccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount) ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Pretty(pretty string) ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) DryRun(dryRun string) ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) FieldManager(fieldManager string) ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	return r.ApiService.CreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusExecute(r)
}

/*
CreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus Method for CreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus

create status of an IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IamAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus(ctx context.Context, name string, namespace string) ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	return ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusExecute(r ApiCreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.CreateAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/namespaces/{namespace}/iamaccounts/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	body *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectRbacReview
	dryRun *string
	fieldManager *string
	pretty *string
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectRbacReview) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest {
	r.body = &body
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest) DryRun(dryRun string) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest) FieldManager(fieldManager string) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest {
	r.fieldManager = &fieldManager
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest) Pretty(pretty string) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest {
	r.pretty = &pretty
	return r
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectRbacReview, *http.Response, error) {
	return r.ApiService.CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewExecute(r)
}

/*
CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReview Method for CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReview

create a SelfSubjectRbacReview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReview(ctx context.Context) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest {
	return ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectRbacReview
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewExecute(r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReviewRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectRbacReview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectRbacReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRbacReview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/selfsubjectrbacreviews"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	body *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectRulesReview
	dryRun *string
	fieldManager *string
	pretty *string
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectRulesReview) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest {
	r.body = &body
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest) DryRun(dryRun string) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest) FieldManager(fieldManager string) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest {
	r.fieldManager = &fieldManager
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest) Pretty(pretty string) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest {
	r.pretty = &pretty
	return r
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectRulesReview, *http.Response, error) {
	return r.ApiService.CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewExecute(r)
}

/*
CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReview Method for CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReview

create a SelfSubjectRulesReview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReview(ctx context.Context) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest {
	return ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectRulesReview
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewExecute(r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReviewRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectRulesReview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectRulesReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectRulesReview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/selfsubjectrulesreviews"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	body *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectUserReview
	dryRun *string
	fieldManager *string
	pretty *string
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectUserReview) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest {
	r.body = &body
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest) DryRun(dryRun string) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest) FieldManager(fieldManager string) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest {
	r.fieldManager = &fieldManager
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest) Pretty(pretty string) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest {
	r.pretty = &pretty
	return r
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectUserReview, *http.Response, error) {
	return r.ApiService.CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewExecute(r)
}

/*
CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReview Method for CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReview

create a SelfSubjectUserReview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReview(ctx context.Context) ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest {
	return ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectUserReview
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewExecute(r ApiCreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReviewRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectUserReview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SelfSubjectUserReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.CreateAuthorizationStreamnativeIoV1alpha1SelfSubjectUserReview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/selfsubjectuserreviews"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	body *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SubjectRoleReview
	dryRun *string
	fieldManager *string
	pretty *string
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SubjectRoleReview) ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest {
	r.body = &body
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest) DryRun(dryRun string) ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest) FieldManager(fieldManager string) ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest {
	r.fieldManager = &fieldManager
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest) Pretty(pretty string) ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest {
	r.pretty = &pretty
	return r
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SubjectRoleReview, *http.Response, error) {
	return r.ApiService.CreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewExecute(r)
}

/*
CreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReview Method for CreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReview

create a SubjectRoleReview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReview(ctx context.Context) ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest {
	return ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SubjectRoleReview
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewExecute(r ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReviewRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SubjectRoleReview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SubjectRoleReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.CreateAuthorizationStreamnativeIoV1alpha1SubjectRoleReview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/subjectrolereviews"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	body *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SubjectRulesReview
	dryRun *string
	fieldManager *string
	pretty *string
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SubjectRulesReview) ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest {
	r.body = &body
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest) DryRun(dryRun string) ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest) FieldManager(fieldManager string) ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest {
	r.fieldManager = &fieldManager
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest) Pretty(pretty string) ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest {
	r.pretty = &pretty
	return r
}

func (r ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SubjectRulesReview, *http.Response, error) {
	return r.ApiService.CreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewExecute(r)
}

/*
CreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReview Method for CreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReview

create a SubjectRulesReview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReview(ctx context.Context) ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest {
	return ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SubjectRulesReview
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) CreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewExecute(r ApiCreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReviewRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SubjectRulesReview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1SubjectRulesReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.CreateAuthorizationStreamnativeIoV1alpha1SubjectRulesReview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/subjectrulesreviews"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) Pretty(pretty string) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) Continue_(continue_ string) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) DryRun(dryRun string) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) FieldSelector(fieldSelector string) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) LabelSelector(labelSelector string) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) Limit(limit int32) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) OrphanDependents(orphanDependents bool) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) PropagationPolicy(propagationPolicy string) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) ResourceVersion(resourceVersion string) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) Body(body V1DeleteOptions) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	r.body = &body
	return r
}

func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountExecute(r)
}

/*
DeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccount Method for DeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccount

delete collection of IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) DeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccount(ctx context.Context, namespace string) ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest {
	return ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) DeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountExecute(r ApiDeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccountRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.DeleteAuthorizationStreamnativeIoV1alpha1CollectionNamespacedIamAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/namespaces/{namespace}/iamaccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Pretty(pretty string) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) DryRun(dryRun string) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) OrphanDependents(orphanDependents bool) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) PropagationPolicy(propagationPolicy string) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Body(body V1DeleteOptions) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.body = &body
	return r
}

func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountExecute(r)
}

/*
DeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount Method for DeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount

delete an IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IamAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) DeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount(ctx context.Context, name string, namespace string) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	return ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) DeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountExecute(r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.DeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/namespaces/{namespace}/iamaccounts/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Pretty(pretty string) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) DryRun(dryRun string) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Body(body V1DeleteOptions) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusExecute(r)
}

/*
DeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus Method for DeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus

delete status of an IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IamAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) DeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus(ctx context.Context, name string, namespace string) ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	return ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) DeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusExecute(r ApiDeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.DeleteAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/namespaces/{namespace}/iamaccounts/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuthorizationStreamnativeIoV1alpha1APIResourcesRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
}

func (r ApiGetAuthorizationStreamnativeIoV1alpha1APIResourcesRequest) Execute() (*V1APIResourceList, *http.Response, error) {
	return r.ApiService.GetAuthorizationStreamnativeIoV1alpha1APIResourcesExecute(r)
}

/*
GetAuthorizationStreamnativeIoV1alpha1APIResources Method for GetAuthorizationStreamnativeIoV1alpha1APIResources

get available resources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuthorizationStreamnativeIoV1alpha1APIResourcesRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) GetAuthorizationStreamnativeIoV1alpha1APIResources(ctx context.Context) ApiGetAuthorizationStreamnativeIoV1alpha1APIResourcesRequest {
	return ApiGetAuthorizationStreamnativeIoV1alpha1APIResourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1APIResourceList
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) GetAuthorizationStreamnativeIoV1alpha1APIResourcesExecute(r ApiGetAuthorizationStreamnativeIoV1alpha1APIResourcesRequest) (*V1APIResourceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1APIResourceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.GetAuthorizationStreamnativeIoV1alpha1APIResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest) Continue_(continue_ string) ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest) Limit(limit int32) ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest) Pretty(pretty string) ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest) Watch(watch bool) ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccountList, *http.Response, error) {
	return r.ApiService.ListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesExecute(r)
}

/*
ListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespaces Method for ListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespaces

list or watch objects of kind IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) ListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespaces(ctx context.Context) ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest {
	return ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccountList
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) ListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesExecute(r ApiListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccountList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccountList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.ListAuthorizationStreamnativeIoV1alpha1IamAccountForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/iamaccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Pretty(pretty string) ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Continue_(continue_ string) ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) FieldSelector(fieldSelector string) ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) LabelSelector(labelSelector string) ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Limit(limit int32) ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) ResourceVersion(resourceVersion string) ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) TimeoutSeconds(timeoutSeconds int32) ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Watch(watch bool) ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.watch = &watch
	return r
}

func (r ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccountList, *http.Response, error) {
	return r.ApiService.ListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountExecute(r)
}

/*
ListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount Method for ListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount

list or watch objects of kind IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) ListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount(ctx context.Context, namespace string) ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	return ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccountList
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) ListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountExecute(r ApiListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccountList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccountList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.ListAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/namespaces/{namespace}/iamaccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Body(body map[string]interface{}) ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Pretty(pretty string) ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) DryRun(dryRun string) ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) FieldManager(fieldManager string) ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Force(force bool) ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.force = &force
	return r
}

func (r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	return r.ApiService.PatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountExecute(r)
}

/*
PatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount Method for PatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount

partially update the specified IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IamAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) PatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount(ctx context.Context, name string, namespace string) ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	return ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) PatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountExecute(r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.PatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/namespaces/{namespace}/iamaccounts/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Body(body map[string]interface{}) ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Pretty(pretty string) ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) DryRun(dryRun string) ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) FieldManager(fieldManager string) ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Force(force bool) ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	return r.ApiService.PatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusExecute(r)
}

/*
PatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus Method for PatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus

partially update status of the specified IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IamAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) PatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus(ctx context.Context, name string, namespace string) ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	return ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) PatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusExecute(r ApiPatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.PatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/namespaces/{namespace}/iamaccounts/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Pretty(pretty string) ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	return r.ApiService.ReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountExecute(r)
}

/*
ReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount Method for ReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount

read the specified IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IamAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) ReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount(ctx context.Context, name string, namespace string) ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	return ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) ReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountExecute(r ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.ReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/namespaces/{namespace}/iamaccounts/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Pretty(pretty string) ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	return r.ApiService.ReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusExecute(r)
}

/*
ReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus Method for ReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus

read status of the specified IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IamAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) ReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus(ctx context.Context, name string, namespace string) ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	return ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) ReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusExecute(r ApiReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.ReadAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/namespaces/{namespace}/iamaccounts/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount) ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Pretty(pretty string) ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) DryRun(dryRun string) ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) FieldManager(fieldManager string) ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	return r.ApiService.ReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountExecute(r)
}

/*
ReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount Method for ReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount

replace the specified IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IamAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) ReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount(ctx context.Context, name string, namespace string) ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest {
	return ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) ReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountExecute(r ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.ReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/namespaces/{namespace}/iamaccounts/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount) ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Pretty(pretty string) ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) DryRun(dryRun string) ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) FieldManager(fieldManager string) ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	return r.ApiService.ReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusExecute(r)
}

/*
ReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus Method for ReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus

replace status of the specified IamAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IamAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) ReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus(ctx context.Context, name string, namespace string) ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	return ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) ReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusExecute(r ApiReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisAuthorizationV1alpha1IamAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.ReplaceAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/namespaces/{namespace}/iamaccounts/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest struct {
	ctx context.Context
	ApiService *AuthorizationStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Continue_(continue_ string) ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) FieldSelector(fieldSelector string) ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) LabelSelector(labelSelector string) ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Limit(limit int32) ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Pretty(pretty string) ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) ResourceVersion(resourceVersion string) ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Watch(watch bool) ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusExecute(r)
}

/*
WatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus Method for WatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus

watch changes to status of an object of kind IamAccount. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IamAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest
*/
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) WatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus(ctx context.Context, name string, namespace string) ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest {
	return ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *AuthorizationStreamnativeIoV1alpha1ApiService) WatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusExecute(r ApiWatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationStreamnativeIoV1alpha1ApiService.WatchAuthorizationStreamnativeIoV1alpha1NamespacedIamAccountStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/authorization.streamnative.io/v1alpha1/watch/namespaces/{namespace}/iamaccounts/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
