//
// Copyright Â© 2023-2024 StreamNative Inc.
//

/*
Api

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sncloud

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// CloudStreamnativeIoV1alpha1ApiService CloudStreamnativeIoV1alpha1Api service
type CloudStreamnativeIoV1alpha1ApiService service

type ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1ClusterRoleExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1ClusterRole Method for CreateCloudStreamnativeIoV1alpha1ClusterRole

create a ClusterRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1ClusterRole(ctx context.Context) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1ClusterRoleExecute(r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1ClusterRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterroles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1ClusterRoleBinding Method for CreateCloudStreamnativeIoV1alpha1ClusterRoleBinding

create a ClusterRoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1ClusterRoleBinding(ctx context.Context) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1ClusterRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterrolebindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus Method for CreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus

create status of a ClusterRoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRoleBinding
 @return ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus(ctx context.Context, name string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterrolebindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1ClusterRoleStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1ClusterRoleStatus Method for CreateCloudStreamnativeIoV1alpha1ClusterRoleStatus

create status of a ClusterRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRole
 @return ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1ClusterRoleStatus(ctx context.Context, name string) ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1ClusterRoleStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1ClusterRoleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterroles/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey) ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedAPIKey Method for CreateCloudStreamnativeIoV1alpha1NamespacedAPIKey

create an APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedAPIKey(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedAPIKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/apikeys"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey) ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus

create status of an APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the APIKey
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/apikeys/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedCloudConnection Method for CreateCloudStreamnativeIoV1alpha1NamespacedCloudConnection

create a CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedCloudConnection(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedCloudConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudconnections"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus

create status of a CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudConnection
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudconnections/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment Method for CreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment

create a CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudenvironments"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus

create status of a CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudEnvironment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudenvironments/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool) ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedIdentityPool Method for CreateCloudStreamnativeIoV1alpha1NamespacedIdentityPool

create an IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedIdentityPool(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedIdentityPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/identitypools"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool) ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus

create status of an IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IdentityPool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/identitypools/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider) ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedOIDCProvider Method for CreateCloudStreamnativeIoV1alpha1NamespacedOIDCProvider

create an OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedOIDCProvider(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedOIDCProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/oidcproviders"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider) ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus

create status of an OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the OIDCProvider
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/oidcproviders/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedPool Method for CreateCloudStreamnativeIoV1alpha1NamespacedPool

create a Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPool(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pools"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedPoolMember Method for CreateCloudStreamnativeIoV1alpha1NamespacedPoolMember

create a PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPoolMember(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPoolMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/poolmembers"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus

create status of a PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolMember
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/poolmembers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedPoolOption Method for CreateCloudStreamnativeIoV1alpha1NamespacedPoolOption

create a PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPoolOption(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPoolOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pooloptions"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus

create status of a PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolOption
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pooloptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedPoolStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedPoolStatus

create status of a Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Pool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPoolStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPoolStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pools/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedPulsarCluster Method for CreateCloudStreamnativeIoV1alpha1NamespacedPulsarCluster

create a PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPulsarCluster(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPulsarCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarclusters"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus

create status of a PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarCluster
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarclusters/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedPulsarGateway Method for CreateCloudStreamnativeIoV1alpha1NamespacedPulsarGateway

create a PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPulsarGateway(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPulsarGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsargateways"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus

create status of a PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarGateway
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsargateways/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstance Method for CreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstance

create a PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstance(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarinstances"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus

create status of a PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarInstance
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarinstances/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedRole Method for CreateCloudStreamnativeIoV1alpha1NamespacedRole

create a Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedRole(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedRoleBinding Method for CreateCloudStreamnativeIoV1alpha1NamespacedRoleBinding

create a RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedRoleBinding(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/rolebindings"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus

create status of a RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the RoleBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedRoleStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedRoleStatus

create status of a Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Role
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedRoleStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedRoleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/roles/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret) ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedSecret Method for CreateCloudStreamnativeIoV1alpha1NamespacedSecret

create a Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedSecret(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret) ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedSecretStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedSecretStatus

create status of a Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Secret
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedSecretStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedSecretStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/secrets/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccount Method for CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccount

create a ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccount(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding Method for CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding

create a ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccountbindings"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus

create status of a ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccountBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccountbindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus

create status of a ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccounts/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription) ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscription Method for CreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscription

create a StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscription(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/stripesubscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription) ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus

create status of a StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the StripeSubscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/stripesubscriptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User) ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedUserExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedUser Method for CreateCloudStreamnativeIoV1alpha1NamespacedUser

create an User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedUser(ctx context.Context, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedUserExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User) ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedUserStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1NamespacedUserStatus Method for CreateCloudStreamnativeIoV1alpha1NamespacedUserStatus

create status of an User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the User
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedUserStatus(ctx context.Context, name string, namespace string) ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1NamespacedUserStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1NamespacedUserStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/users/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization) ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1OrganizationExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1Organization Method for CreateCloudStreamnativeIoV1alpha1Organization

create an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1Organization(ctx context.Context) ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1OrganizationExecute(r ApiCreateCloudStreamnativeIoV1alpha1OrganizationRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1Organization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization) ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1OrganizationStatusExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1OrganizationStatus Method for CreateCloudStreamnativeIoV1alpha1OrganizationStatus

create status of an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Organization
 @return ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1OrganizationStatus(ctx context.Context, name string) ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1OrganizationStatusExecute(r ApiCreateCloudStreamnativeIoV1alpha1OrganizationStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1OrganizationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/organizations/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SelfRegistration
	dryRun *string
	fieldManager *string
	pretty *string
}

func (r ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SelfRegistration) ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest {
	r.body = &body
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest) DryRun(dryRun string) ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest) FieldManager(fieldManager string) ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest {
	r.fieldManager = &fieldManager
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest) Pretty(pretty string) ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest {
	r.pretty = &pretty
	return r
}

func (r ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SelfRegistration, *http.Response, error) {
	return r.ApiService.CreateCloudStreamnativeIoV1alpha1SelfRegistrationExecute(r)
}

/*
CreateCloudStreamnativeIoV1alpha1SelfRegistration Method for CreateCloudStreamnativeIoV1alpha1SelfRegistration

create a SelfRegistration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1SelfRegistration(ctx context.Context) ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest {
	return ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SelfRegistration
func (a *CloudStreamnativeIoV1alpha1ApiService) CreateCloudStreamnativeIoV1alpha1SelfRegistrationExecute(r ApiCreateCloudStreamnativeIoV1alpha1SelfRegistrationRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SelfRegistration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SelfRegistration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.CreateCloudStreamnativeIoV1alpha1SelfRegistration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/selfregistrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1ClusterRoleExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1ClusterRole Method for DeleteCloudStreamnativeIoV1alpha1ClusterRole

delete a ClusterRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRole
 @return ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1ClusterRole(ctx context.Context, name string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1ClusterRoleExecute(r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1ClusterRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterroles/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1ClusterRoleBinding Method for DeleteCloudStreamnativeIoV1alpha1ClusterRoleBinding

delete a ClusterRoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRoleBinding
 @return ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1ClusterRoleBinding(ctx context.Context, name string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1ClusterRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterrolebindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus Method for DeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus

delete status of a ClusterRoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRoleBinding
 @return ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus(ctx context.Context, name string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterrolebindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1ClusterRoleStatus Method for DeleteCloudStreamnativeIoV1alpha1ClusterRoleStatus

delete status of a ClusterRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRole
 @return ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1ClusterRoleStatus(ctx context.Context, name string) ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1ClusterRoleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterroles/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionClusterRole Method for DeleteCloudStreamnativeIoV1alpha1CollectionClusterRole

delete collection of ClusterRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionClusterRole(ctx context.Context) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionClusterRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterroles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBinding Method for DeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBinding

delete collection of ClusterRoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBinding(ctx context.Context) ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBindingRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionClusterRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterrolebindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKey Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKey

delete collection of APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKey(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKeyRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedAPIKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/apikeys"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnection Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnection

delete collection of CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnection(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnectionRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudconnections"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironment Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironment

delete collection of CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironment(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironmentRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedCloudEnvironment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudenvironments"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPool Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPool

delete collection of IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPool(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPoolRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedIdentityPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/identitypools"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProvider Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProvider

delete collection of OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProvider(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProviderRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedOIDCProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/oidcproviders"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPool Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPool

delete collection of Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPool(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pools"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMember Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMember

delete collection of PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMember(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMemberRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/poolmembers"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOption Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOption

delete collection of PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOption(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOptionRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPoolOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pooloptions"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarCluster Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarCluster

delete collection of PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarCluster(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarClusterRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarclusters"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGateway Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGateway

delete collection of PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGateway(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGatewayRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsargateways"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstance Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstance

delete collection of PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstance(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstanceRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedPulsarInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarinstances"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRole Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRole

delete collection of Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRole(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBinding Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBinding

delete collection of RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBinding(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBindingRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/rolebindings"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecret Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecret

delete collection of Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecret(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecretRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccount Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccount

delete collection of ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccount(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBinding Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBinding

delete collection of ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBinding(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBindingRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedServiceAccountBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccountbindings"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscription Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscription

delete collection of StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscription(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscriptionRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedStripeSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/stripesubscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUser Method for DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUser

delete collection of User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUser(ctx context.Context, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUserRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionNamespacedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) Continue_(continue_ string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) FieldSelector(fieldSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) LabelSelector(labelSelector string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) Limit(limit int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) ResourceVersion(resourceVersion string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionOrganizationExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1CollectionOrganization Method for DeleteCloudStreamnativeIoV1alpha1CollectionOrganization

delete collection of Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionOrganization(ctx context.Context) ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1CollectionOrganizationExecute(r ApiDeleteCloudStreamnativeIoV1alpha1CollectionOrganizationRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1CollectionOrganization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedAPIKey Method for DeleteCloudStreamnativeIoV1alpha1NamespacedAPIKey

delete an APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the APIKey
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedAPIKey(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedAPIKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/apikeys/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus

delete status of an APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the APIKey
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/apikeys/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnection Method for DeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnection

delete a CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudConnection
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnection(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudconnections/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus

delete status of a CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudConnection
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudconnections/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment Method for DeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment

delete a CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudEnvironment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudenvironments/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus

delete status of a CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudEnvironment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudenvironments/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPool Method for DeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPool

delete an IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IdentityPool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPool(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/identitypools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus

delete status of an IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IdentityPool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/identitypools/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProvider Method for DeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProvider

delete an OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the OIDCProvider
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProvider(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/oidcproviders/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus

delete status of an OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the OIDCProvider
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/oidcproviders/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedPool Method for DeleteCloudStreamnativeIoV1alpha1NamespacedPool

delete a Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Pool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPool(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedPoolMember Method for DeleteCloudStreamnativeIoV1alpha1NamespacedPoolMember

delete a PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolMember
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPoolMember(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPoolMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/poolmembers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus

delete status of a PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolMember
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/poolmembers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedPoolOption Method for DeleteCloudStreamnativeIoV1alpha1NamespacedPoolOption

delete a PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolOption
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPoolOption(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPoolOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pooloptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus

delete status of a PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolOption
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pooloptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatus

delete status of a Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Pool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPoolStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pools/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarCluster Method for DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarCluster

delete a PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarCluster
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarCluster(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarclusters/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus

delete status of a PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarCluster
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarclusters/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGateway Method for DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGateway

delete a PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarGateway
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGateway(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsargateways/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus

delete status of a PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarGateway
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsargateways/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstance Method for DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstance

delete a PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarInstance
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstance(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarinstances/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus

delete status of a PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarInstance
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarinstances/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedRole Method for DeleteCloudStreamnativeIoV1alpha1NamespacedRole

delete a Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Role
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedRole(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/roles/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedRoleBinding Method for DeleteCloudStreamnativeIoV1alpha1NamespacedRoleBinding

delete a RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the RoleBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedRoleBinding(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus

delete status of a RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the RoleBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatus

delete status of a Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Role
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedRoleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/roles/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedSecret Method for DeleteCloudStreamnativeIoV1alpha1NamespacedSecret

delete a Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Secret
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedSecret(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/secrets/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatus

delete status of a Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Secret
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedSecretStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/secrets/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccount Method for DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccount

delete a ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccount(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccounts/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding Method for DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding

delete a ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccountBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccountbindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus

delete status of a ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccountBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccountbindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus

delete status of a ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccounts/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscription Method for DeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscription

delete a StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the StripeSubscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscription(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/stripesubscriptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus

delete status of a StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the StripeSubscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/stripesubscriptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedUserExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedUser Method for DeleteCloudStreamnativeIoV1alpha1NamespacedUser

delete an User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the User
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedUser(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedUserExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/users/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1NamespacedUserStatus Method for DeleteCloudStreamnativeIoV1alpha1NamespacedUserStatus

delete status of an User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the User
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedUserStatus(ctx context.Context, name string, namespace string) ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1NamespacedUserStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/users/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1OrganizationExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1Organization Method for DeleteCloudStreamnativeIoV1alpha1Organization

delete an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Organization
 @return ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1Organization(ctx context.Context, name string) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1OrganizationExecute(r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1Organization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/organizations/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Pretty(pretty string) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest) DryRun(dryRun string) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Body(body V1DeleteOptions) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteCloudStreamnativeIoV1alpha1OrganizationStatusExecute(r)
}

/*
DeleteCloudStreamnativeIoV1alpha1OrganizationStatus Method for DeleteCloudStreamnativeIoV1alpha1OrganizationStatus

delete status of an Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Organization
 @return ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1OrganizationStatus(ctx context.Context, name string) ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	return ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1Status
func (a *CloudStreamnativeIoV1alpha1ApiService) DeleteCloudStreamnativeIoV1alpha1OrganizationStatusExecute(r ApiDeleteCloudStreamnativeIoV1alpha1OrganizationStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.DeleteCloudStreamnativeIoV1alpha1OrganizationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/organizations/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCloudStreamnativeIoV1alpha1APIResourcesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
}

func (r ApiGetCloudStreamnativeIoV1alpha1APIResourcesRequest) Execute() (*V1APIResourceList, *http.Response, error) {
	return r.ApiService.GetCloudStreamnativeIoV1alpha1APIResourcesExecute(r)
}

/*
GetCloudStreamnativeIoV1alpha1APIResources Method for GetCloudStreamnativeIoV1alpha1APIResources

get available resources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCloudStreamnativeIoV1alpha1APIResourcesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) GetCloudStreamnativeIoV1alpha1APIResources(ctx context.Context) ApiGetCloudStreamnativeIoV1alpha1APIResourcesRequest {
	return ApiGetCloudStreamnativeIoV1alpha1APIResourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1APIResourceList
func (a *CloudStreamnativeIoV1alpha1ApiService) GetCloudStreamnativeIoV1alpha1APIResourcesExecute(r ApiGetCloudStreamnativeIoV1alpha1APIResourcesRequest) (*V1APIResourceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1APIResourceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.GetCloudStreamnativeIoV1alpha1APIResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKeyList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1APIKeyForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1APIKeyForAllNamespaces

list or watch objects of kind APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1APIKeyForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKeyList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1APIKeyForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKeyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKeyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1APIKeyForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/apikeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnectionList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespaces

list or watch objects of kind CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnectionList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnectionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnectionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1CloudConnectionForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/cloudconnections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironmentList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespaces

list or watch objects of kind CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironmentList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironmentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironmentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1CloudEnvironmentForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/cloudenvironments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1ClusterRoleExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1ClusterRole Method for ListCloudStreamnativeIoV1alpha1ClusterRole

list or watch objects of kind ClusterRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1ClusterRole(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	return ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1ClusterRoleExecute(r ApiListCloudStreamnativeIoV1alpha1ClusterRoleRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1ClusterRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterroles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBindingList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1ClusterRoleBinding Method for ListCloudStreamnativeIoV1alpha1ClusterRoleBinding

list or watch objects of kind ClusterRoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1ClusterRoleBinding(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	return ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBindingList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r ApiListCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBindingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBindingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1ClusterRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterrolebindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPoolList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespaces

list or watch objects of kind IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPoolList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPoolList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPoolList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1IdentityPoolForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/identitypools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKeyList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedAPIKey Method for ListCloudStreamnativeIoV1alpha1NamespacedAPIKey

list or watch objects of kind APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedAPIKey(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKeyList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKeyList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKeyList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedAPIKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/apikeys"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnectionList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedCloudConnection Method for ListCloudStreamnativeIoV1alpha1NamespacedCloudConnection

list or watch objects of kind CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedCloudConnection(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnectionList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnectionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnectionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedCloudConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudconnections"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironmentList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment Method for ListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment

list or watch objects of kind CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironmentList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironmentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironmentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudenvironments"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPoolList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedIdentityPool Method for ListCloudStreamnativeIoV1alpha1NamespacedIdentityPool

list or watch objects of kind IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedIdentityPool(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPoolList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPoolList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPoolList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedIdentityPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/identitypools"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProviderList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedOIDCProvider Method for ListCloudStreamnativeIoV1alpha1NamespacedOIDCProvider

list or watch objects of kind OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedOIDCProvider(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProviderList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProviderList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProviderList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedOIDCProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/oidcproviders"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedPool Method for ListCloudStreamnativeIoV1alpha1NamespacedPool

list or watch objects of kind Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedPool(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pools"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMemberList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedPoolMember Method for ListCloudStreamnativeIoV1alpha1NamespacedPoolMember

list or watch objects of kind PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedPoolMember(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMemberList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMemberList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMemberList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedPoolMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/poolmembers"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOptionList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedPoolOption Method for ListCloudStreamnativeIoV1alpha1NamespacedPoolOption

list or watch objects of kind PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedPoolOption(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOptionList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOptionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedPoolOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pooloptions"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarClusterList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedPulsarCluster Method for ListCloudStreamnativeIoV1alpha1NamespacedPulsarCluster

list or watch objects of kind PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedPulsarCluster(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarClusterList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarClusterList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarClusterList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedPulsarCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarclusters"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGatewayList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedPulsarGateway Method for ListCloudStreamnativeIoV1alpha1NamespacedPulsarGateway

list or watch objects of kind PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedPulsarGateway(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGatewayList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGatewayList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGatewayList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedPulsarGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsargateways"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstanceList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedPulsarInstance Method for ListCloudStreamnativeIoV1alpha1NamespacedPulsarInstance

list or watch objects of kind PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedPulsarInstance(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstanceList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstanceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstanceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedPulsarInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarinstances"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedRole Method for ListCloudStreamnativeIoV1alpha1NamespacedRole

list or watch objects of kind Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedRole(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBindingList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedRoleBinding Method for ListCloudStreamnativeIoV1alpha1NamespacedRoleBinding

list or watch objects of kind RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedRoleBinding(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBindingList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBindingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBindingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/rolebindings"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SecretList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedSecret Method for ListCloudStreamnativeIoV1alpha1NamespacedSecret

list or watch objects of kind Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedSecret(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SecretList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedSecretRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SecretList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SecretList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedServiceAccount Method for ListCloudStreamnativeIoV1alpha1NamespacedServiceAccount

list or watch objects of kind ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedServiceAccount(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedServiceAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBindingList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding Method for ListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding

list or watch objects of kind ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBindingList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBindingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBindingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccountbindings"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscriptionList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedStripeSubscription Method for ListCloudStreamnativeIoV1alpha1NamespacedStripeSubscription

list or watch objects of kind StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedStripeSubscription(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscriptionList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscriptionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscriptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedStripeSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/stripesubscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1UserList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1NamespacedUserExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1NamespacedUser Method for ListCloudStreamnativeIoV1alpha1NamespacedUser

list or watch objects of kind User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedUser(ctx context.Context, namespace string) ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	return ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1UserList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1NamespacedUserExecute(r ApiListCloudStreamnativeIoV1alpha1NamespacedUserRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1UserList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1UserList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1NamespacedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProviderList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespaces

list or watch objects of kind OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProviderList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProviderList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProviderList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1OIDCProviderForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/oidcproviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1OrganizationRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1OrganizationRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1OrganizationRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1OrganizationRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1OrganizationRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1OrganizationRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1OrganizationRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1OrganizationRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1OrganizationRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1OrganizationRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1OrganizationRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1OrganizationRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OrganizationList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1OrganizationExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1Organization Method for ListCloudStreamnativeIoV1alpha1Organization

list or watch objects of kind Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1OrganizationRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1Organization(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1OrganizationRequest {
	return ApiListCloudStreamnativeIoV1alpha1OrganizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OrganizationList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1OrganizationExecute(r ApiListCloudStreamnativeIoV1alpha1OrganizationRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OrganizationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OrganizationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1Organization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1PoolForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1PoolForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1PoolForAllNamespaces

list or watch objects of kind Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1PoolForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1PoolForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1PoolForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1PoolForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMemberList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespaces

list or watch objects of kind PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMemberList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMemberList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMemberList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1PoolMemberForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/poolmembers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOptionList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespaces

list or watch objects of kind PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOptionList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOptionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1PoolOptionForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/pooloptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarClusterList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespaces

list or watch objects of kind PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarClusterList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarClusterList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarClusterList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1PulsarClusterForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/pulsarclusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGatewayList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespaces

list or watch objects of kind PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGatewayList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGatewayList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGatewayList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1PulsarGatewayForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/pulsargateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstanceList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespaces

list or watch objects of kind PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstanceList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstanceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstanceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1PulsarInstanceForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/pulsarinstances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBindingList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespaces

list or watch objects of kind RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBindingList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBindingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBindingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1RoleBindingForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/rolebindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1RoleForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1RoleForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1RoleForAllNamespaces

list or watch objects of kind Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1RoleForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1RoleForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1RoleForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1RoleForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SecretList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1SecretForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1SecretForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1SecretForAllNamespaces

list or watch objects of kind Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1SecretForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SecretList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1SecretForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1SecretForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SecretList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1SecretList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1SecretForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/secrets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBindingList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespaces

list or watch objects of kind ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBindingList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBindingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBindingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1ServiceAccountBindingForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/serviceaccountbindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespaces

list or watch objects of kind ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1ServiceAccountForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/serviceaccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscriptionList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespaces

list or watch objects of kind StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscriptionList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscriptionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscriptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1StripeSubscriptionForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/stripesubscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest) Continue_(continue_ string) ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest) Limit(limit int32) ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest) Pretty(pretty string) ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest) Watch(watch bool) ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1UserList, *http.Response, error) {
	return r.ApiService.ListCloudStreamnativeIoV1alpha1UserForAllNamespacesExecute(r)
}

/*
ListCloudStreamnativeIoV1alpha1UserForAllNamespaces Method for ListCloudStreamnativeIoV1alpha1UserForAllNamespaces

list or watch objects of kind User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1UserForAllNamespaces(ctx context.Context) ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest {
	return ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1UserList
func (a *CloudStreamnativeIoV1alpha1ApiService) ListCloudStreamnativeIoV1alpha1UserForAllNamespacesExecute(r ApiListCloudStreamnativeIoV1alpha1UserForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1UserList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1UserList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ListCloudStreamnativeIoV1alpha1UserForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1ClusterRoleExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1ClusterRole Method for PatchCloudStreamnativeIoV1alpha1ClusterRole

partially update the specified ClusterRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRole
 @return ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1ClusterRole(ctx context.Context, name string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1ClusterRoleExecute(r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1ClusterRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterroles/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1ClusterRoleBinding Method for PatchCloudStreamnativeIoV1alpha1ClusterRoleBinding

partially update the specified ClusterRoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRoleBinding
 @return ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1ClusterRoleBinding(ctx context.Context, name string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1ClusterRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterrolebindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus Method for PatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus

partially update status of the specified ClusterRoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRoleBinding
 @return ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus(ctx context.Context, name string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterrolebindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1ClusterRoleStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1ClusterRoleStatus Method for PatchCloudStreamnativeIoV1alpha1ClusterRoleStatus

partially update status of the specified ClusterRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRole
 @return ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1ClusterRoleStatus(ctx context.Context, name string) ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1ClusterRoleStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1ClusterRoleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterroles/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedAPIKey Method for PatchCloudStreamnativeIoV1alpha1NamespacedAPIKey

partially update the specified APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the APIKey
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedAPIKey(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedAPIKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/apikeys/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus

partially update status of the specified APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the APIKey
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/apikeys/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedCloudConnection Method for PatchCloudStreamnativeIoV1alpha1NamespacedCloudConnection

partially update the specified CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudConnection
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedCloudConnection(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedCloudConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudconnections/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus

partially update status of the specified CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudConnection
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudconnections/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment Method for PatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment

partially update the specified CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudEnvironment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudenvironments/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus

partially update status of the specified CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudEnvironment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudenvironments/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedIdentityPool Method for PatchCloudStreamnativeIoV1alpha1NamespacedIdentityPool

partially update the specified IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IdentityPool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedIdentityPool(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedIdentityPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/identitypools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus

partially update status of the specified IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IdentityPool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/identitypools/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedOIDCProvider Method for PatchCloudStreamnativeIoV1alpha1NamespacedOIDCProvider

partially update the specified OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the OIDCProvider
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedOIDCProvider(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedOIDCProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/oidcproviders/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus

partially update status of the specified OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the OIDCProvider
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/oidcproviders/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedPool Method for PatchCloudStreamnativeIoV1alpha1NamespacedPool

partially update the specified Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Pool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPool(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedPoolMember Method for PatchCloudStreamnativeIoV1alpha1NamespacedPoolMember

partially update the specified PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolMember
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPoolMember(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPoolMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/poolmembers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus

partially update status of the specified PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolMember
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/poolmembers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedPoolOption Method for PatchCloudStreamnativeIoV1alpha1NamespacedPoolOption

partially update the specified PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolOption
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPoolOption(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPoolOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pooloptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus

partially update status of the specified PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolOption
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pooloptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedPoolStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedPoolStatus

partially update status of the specified Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Pool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPoolStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPoolStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pools/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedPulsarCluster Method for PatchCloudStreamnativeIoV1alpha1NamespacedPulsarCluster

partially update the specified PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarCluster
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPulsarCluster(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPulsarCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarclusters/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus

partially update status of the specified PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarCluster
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarclusters/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedPulsarGateway Method for PatchCloudStreamnativeIoV1alpha1NamespacedPulsarGateway

partially update the specified PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarGateway
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPulsarGateway(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPulsarGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsargateways/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus

partially update status of the specified PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarGateway
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsargateways/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstance Method for PatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstance

partially update the specified PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarInstance
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstance(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarinstances/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus

partially update status of the specified PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarInstance
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarinstances/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedRole Method for PatchCloudStreamnativeIoV1alpha1NamespacedRole

partially update the specified Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Role
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedRole(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/roles/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedRoleBinding Method for PatchCloudStreamnativeIoV1alpha1NamespacedRoleBinding

partially update the specified RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the RoleBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedRoleBinding(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus

partially update status of the specified RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the RoleBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedRoleStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedRoleStatus

partially update status of the specified Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Role
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedRoleStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedRoleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/roles/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedSecret Method for PatchCloudStreamnativeIoV1alpha1NamespacedSecret

partially update the specified Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Secret
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedSecret(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/secrets/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedSecretStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedSecretStatus

partially update status of the specified Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Secret
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedSecretStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedSecretStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/secrets/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccount Method for PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccount

partially update the specified ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccount(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccounts/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding Method for PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding

partially update the specified ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccountBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccountbindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus

partially update status of the specified ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccountBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccountbindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus

partially update status of the specified ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccounts/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscription Method for PatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscription

partially update the specified StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the StripeSubscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscription(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/stripesubscriptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus

partially update status of the specified StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the StripeSubscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/stripesubscriptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedUserExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedUser Method for PatchCloudStreamnativeIoV1alpha1NamespacedUser

partially update the specified User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the User
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedUser(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedUserExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/users/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedUserStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1NamespacedUserStatus Method for PatchCloudStreamnativeIoV1alpha1NamespacedUserStatus

partially update status of the specified User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the User
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedUserStatus(ctx context.Context, name string, namespace string) ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1NamespacedUserStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1NamespacedUserStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/users/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1OrganizationExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1Organization Method for PatchCloudStreamnativeIoV1alpha1Organization

partially update the specified Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Organization
 @return ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1Organization(ctx context.Context, name string) ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1OrganizationExecute(r ApiPatchCloudStreamnativeIoV1alpha1OrganizationRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1Organization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/organizations/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Body(body map[string]interface{}) ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Pretty(pretty string) ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) DryRun(dryRun string) ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) FieldManager(fieldManager string) ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Force(force bool) ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	return r.ApiService.PatchCloudStreamnativeIoV1alpha1OrganizationStatusExecute(r)
}

/*
PatchCloudStreamnativeIoV1alpha1OrganizationStatus Method for PatchCloudStreamnativeIoV1alpha1OrganizationStatus

partially update status of the specified Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Organization
 @return ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1OrganizationStatus(ctx context.Context, name string) ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	return ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
func (a *CloudStreamnativeIoV1alpha1ApiService) PatchCloudStreamnativeIoV1alpha1OrganizationStatusExecute(r ApiPatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.PatchCloudStreamnativeIoV1alpha1OrganizationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/organizations/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1ClusterRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1ClusterRoleRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1ClusterRoleRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1ClusterRoleExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1ClusterRole Method for ReadCloudStreamnativeIoV1alpha1ClusterRole

read the specified ClusterRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRole
 @return ApiReadCloudStreamnativeIoV1alpha1ClusterRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1ClusterRole(ctx context.Context, name string) ApiReadCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	return ApiReadCloudStreamnativeIoV1alpha1ClusterRoleRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1ClusterRoleExecute(r ApiReadCloudStreamnativeIoV1alpha1ClusterRoleRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1ClusterRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterroles/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1ClusterRoleBinding Method for ReadCloudStreamnativeIoV1alpha1ClusterRoleBinding

read the specified ClusterRoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRoleBinding
 @return ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1ClusterRoleBinding(ctx context.Context, name string) ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	return ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1ClusterRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterrolebindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus Method for ReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus

read status of the specified ClusterRoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRoleBinding
 @return ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus(ctx context.Context, name string) ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterrolebindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1ClusterRoleStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1ClusterRoleStatus Method for ReadCloudStreamnativeIoV1alpha1ClusterRoleStatus

read status of the specified ClusterRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRole
 @return ApiReadCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1ClusterRoleStatus(ctx context.Context, name string) ApiReadCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1ClusterRoleStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1ClusterRoleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterroles/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedAPIKey Method for ReadCloudStreamnativeIoV1alpha1NamespacedAPIKey

read the specified APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the APIKey
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedAPIKey(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedAPIKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/apikeys/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus

read status of the specified APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the APIKey
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/apikeys/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedCloudConnection Method for ReadCloudStreamnativeIoV1alpha1NamespacedCloudConnection

read the specified CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudConnection
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedCloudConnection(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedCloudConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudconnections/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus

read status of the specified CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudConnection
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudconnections/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment Method for ReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment

read the specified CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudEnvironment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudenvironments/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus

read status of the specified CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudEnvironment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudenvironments/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedIdentityPool Method for ReadCloudStreamnativeIoV1alpha1NamespacedIdentityPool

read the specified IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IdentityPool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedIdentityPool(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedIdentityPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/identitypools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus

read status of the specified IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IdentityPool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/identitypools/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedOIDCProvider Method for ReadCloudStreamnativeIoV1alpha1NamespacedOIDCProvider

read the specified OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the OIDCProvider
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedOIDCProvider(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedOIDCProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/oidcproviders/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus

read status of the specified OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the OIDCProvider
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/oidcproviders/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedPool Method for ReadCloudStreamnativeIoV1alpha1NamespacedPool

read the specified Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Pool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPool(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedPoolMember Method for ReadCloudStreamnativeIoV1alpha1NamespacedPoolMember

read the specified PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolMember
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPoolMember(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPoolMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/poolmembers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus

read status of the specified PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolMember
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/poolmembers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedPoolOption Method for ReadCloudStreamnativeIoV1alpha1NamespacedPoolOption

read the specified PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolOption
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPoolOption(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPoolOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pooloptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus

read status of the specified PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolOption
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pooloptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPoolStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedPoolStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedPoolStatus

read status of the specified Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Pool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPoolStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPoolStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPoolStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pools/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedPulsarCluster Method for ReadCloudStreamnativeIoV1alpha1NamespacedPulsarCluster

read the specified PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarCluster
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPulsarCluster(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPulsarCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarclusters/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus

read status of the specified PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarCluster
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarclusters/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedPulsarGateway Method for ReadCloudStreamnativeIoV1alpha1NamespacedPulsarGateway

read the specified PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarGateway
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPulsarGateway(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPulsarGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsargateways/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus

read status of the specified PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarGateway
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsargateways/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstance Method for ReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstance

read the specified PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarInstance
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstance(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarinstances/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus

read status of the specified PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarInstance
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarinstances/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedRole Method for ReadCloudStreamnativeIoV1alpha1NamespacedRole

read the specified Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Role
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedRole(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/roles/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedRoleBinding Method for ReadCloudStreamnativeIoV1alpha1NamespacedRoleBinding

read the specified RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the RoleBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedRoleBinding(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus

read status of the specified RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the RoleBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedRoleStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedRoleStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedRoleStatus

read status of the specified Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Role
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedRoleStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedRoleStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedRoleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/roles/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedSecret Method for ReadCloudStreamnativeIoV1alpha1NamespacedSecret

read the specified Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Secret
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedSecret(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/secrets/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedSecretStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedSecretStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedSecretStatus

read status of the specified Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Secret
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedSecretStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedSecretStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedSecretStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/secrets/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccount Method for ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccount

read the specified ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccount(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccounts/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding Method for ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding

read the specified ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccountBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccountbindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus

read status of the specified ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccountBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccountbindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus

read status of the specified ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccounts/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscription Method for ReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscription

read the specified StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the StripeSubscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscription(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/stripesubscriptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus

read status of the specified StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the StripeSubscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/stripesubscriptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedUserRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedUserRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedUserRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedUserExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedUser Method for ReadCloudStreamnativeIoV1alpha1NamespacedUser

read the specified User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the User
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedUserRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedUser(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedUserExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedUserRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/users/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedUserStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1NamespacedUserStatus Method for ReadCloudStreamnativeIoV1alpha1NamespacedUserStatus

read status of the specified User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the User
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedUserStatus(ctx context.Context, name string, namespace string) ApiReadCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1NamespacedUserStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1NamespacedUserStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/users/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1OrganizationRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1OrganizationRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1OrganizationRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1OrganizationExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1Organization Method for ReadCloudStreamnativeIoV1alpha1Organization

read the specified Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Organization
 @return ApiReadCloudStreamnativeIoV1alpha1OrganizationRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1Organization(ctx context.Context, name string) ApiReadCloudStreamnativeIoV1alpha1OrganizationRequest {
	return ApiReadCloudStreamnativeIoV1alpha1OrganizationRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1OrganizationExecute(r ApiReadCloudStreamnativeIoV1alpha1OrganizationRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1Organization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/organizations/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCloudStreamnativeIoV1alpha1OrganizationStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Pretty(pretty string) ApiReadCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	return r.ApiService.ReadCloudStreamnativeIoV1alpha1OrganizationStatusExecute(r)
}

/*
ReadCloudStreamnativeIoV1alpha1OrganizationStatus Method for ReadCloudStreamnativeIoV1alpha1OrganizationStatus

read status of the specified Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Organization
 @return ApiReadCloudStreamnativeIoV1alpha1OrganizationStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1OrganizationStatus(ctx context.Context, name string) ApiReadCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	return ApiReadCloudStreamnativeIoV1alpha1OrganizationStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
func (a *CloudStreamnativeIoV1alpha1ApiService) ReadCloudStreamnativeIoV1alpha1OrganizationStatusExecute(r ApiReadCloudStreamnativeIoV1alpha1OrganizationStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReadCloudStreamnativeIoV1alpha1OrganizationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/organizations/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1ClusterRoleExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1ClusterRole Method for ReplaceCloudStreamnativeIoV1alpha1ClusterRole

replace the specified ClusterRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRole
 @return ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1ClusterRole(ctx context.Context, name string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1ClusterRoleExecute(r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1ClusterRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterroles/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1ClusterRoleBinding Method for ReplaceCloudStreamnativeIoV1alpha1ClusterRoleBinding

replace the specified ClusterRoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRoleBinding
 @return ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1ClusterRoleBinding(ctx context.Context, name string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1ClusterRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterrolebindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus Method for ReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus

replace status of the specified ClusterRoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRoleBinding
 @return ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus(ctx context.Context, name string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterrolebindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatus Method for ReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatus

replace status of the specified ClusterRole

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRole
 @return ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatus(ctx context.Context, name string) ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ClusterRole
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1ClusterRoleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/clusterroles/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKey Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKey

replace the specified APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the APIKey
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKey(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/apikeys/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus

replace status of the specified APIKey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the APIKey
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1APIKey
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/apikeys/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnection Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnection

replace the specified CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudConnection
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnection(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudconnections/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus

replace status of the specified CloudConnection

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudConnection
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudConnection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudconnections/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment

replace the specified CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudEnvironment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudenvironments/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus

replace status of the specified CloudEnvironment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudEnvironment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1CloudEnvironment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/cloudenvironments/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPool Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPool

replace the specified IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IdentityPool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPool(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/identitypools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus

replace status of the specified IdentityPool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IdentityPool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1IdentityPool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/identitypools/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProvider Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProvider

replace the specified OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the OIDCProvider
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProvider(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/oidcproviders/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus

replace status of the specified OIDCProvider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the OIDCProvider
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1OIDCProvider
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/oidcproviders/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedPool Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedPool

replace the specified Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Pool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPool(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMember Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMember

replace the specified PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolMember
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMember(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/poolmembers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus

replace status of the specified PoolMember

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolMember
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolMember
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/poolmembers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOption Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOption

replace the specified PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolOption
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOption(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pooloptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus

replace status of the specified PoolOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolOption
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PoolOption
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pooloptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatus

replace status of the specified Pool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Pool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Pool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPoolStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pools/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarCluster Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarCluster

replace the specified PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarCluster
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarCluster(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarclusters/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus

replace status of the specified PulsarCluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarCluster
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarCluster
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarclusters/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGateway Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGateway

replace the specified PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarGateway
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGateway(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsargateways/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus

replace status of the specified PulsarGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarGateway
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarGateway
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsargateways/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstance Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstance

replace the specified PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarInstance
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstance(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarinstances/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus

replace status of the specified PulsarInstance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarInstance
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1PulsarInstance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/pulsarinstances/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedRole Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedRole

replace the specified Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Role
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedRole(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/roles/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBinding Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBinding

replace the specified RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the RoleBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBinding(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus

replace status of the specified RoleBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the RoleBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1RoleBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/rolebindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatus

replace status of the specified Role

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Role
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Role
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedRoleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/roles/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedSecret Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedSecret

replace the specified Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Secret
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedSecret(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/secrets/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatus

replace status of the specified Secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Secret
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Secret
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedSecretStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/secrets/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccount Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccount

replace the specified ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccount(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccounts/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding

replace the specified ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccountBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccountbindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus

replace status of the specified ServiceAccountBinding

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccountBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccountBinding
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccountbindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus

replace status of the specified ServiceAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1ServiceAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/serviceaccounts/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscription Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscription

replace the specified StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the StripeSubscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscription(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/stripesubscriptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus

replace status of the specified StripeSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the StripeSubscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1StripeSubscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/stripesubscriptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedUserExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedUser Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedUser

replace the specified User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the User
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedUser(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedUserExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/users/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatus Method for ReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatus

replace status of the specified User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the User
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatus(ctx context.Context, name string, namespace string) ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1User
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1NamespacedUserStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/namespaces/{namespace}/users/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization) ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1OrganizationExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1Organization Method for ReplaceCloudStreamnativeIoV1alpha1Organization

replace the specified Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Organization
 @return ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1Organization(ctx context.Context, name string) ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1OrganizationExecute(r ApiReplaceCloudStreamnativeIoV1alpha1OrganizationRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1Organization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/organizations/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization) ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Pretty(pretty string) ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest) DryRun(dryRun string) ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest) FieldManager(fieldManager string) ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	return r.ApiService.ReplaceCloudStreamnativeIoV1alpha1OrganizationStatusExecute(r)
}

/*
ReplaceCloudStreamnativeIoV1alpha1OrganizationStatus Method for ReplaceCloudStreamnativeIoV1alpha1OrganizationStatus

replace status of the specified Organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Organization
 @return ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1OrganizationStatus(ctx context.Context, name string) ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	return ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
func (a *CloudStreamnativeIoV1alpha1ApiService) ReplaceCloudStreamnativeIoV1alpha1OrganizationStatusExecute(r ApiReplaceCloudStreamnativeIoV1alpha1OrganizationStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisCloudV1alpha1Organization
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.ReplaceCloudStreamnativeIoV1alpha1OrganizationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/organizations/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespaces

watch individual changes to a list of APIKey. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1APIKeyListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/apikeys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespaces

watch individual changes to a list of CloudConnection. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1CloudConnectionListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/cloudconnections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespaces

watch individual changes to a list of CloudEnvironment. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1CloudEnvironmentListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/cloudenvironments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1ClusterRoleExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1ClusterRole Method for WatchCloudStreamnativeIoV1alpha1ClusterRole

watch changes to an object of kind ClusterRole. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRole
 @return ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ClusterRole(ctx context.Context, name string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ClusterRoleExecute(r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1ClusterRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/clusterroles/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1ClusterRoleBinding Method for WatchCloudStreamnativeIoV1alpha1ClusterRoleBinding

watch changes to an object of kind ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRoleBinding
 @return ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ClusterRoleBinding(ctx context.Context, name string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingExecute(r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1ClusterRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/clusterrolebindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingList Method for WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingList

watch individual changes to a list of ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingList(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListExecute(r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/clusterrolebindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus Method for WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus

watch changes to status of an object of kind ClusterRoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRoleBinding
 @return ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus(ctx context.Context, name string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1ClusterRoleBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/clusterrolebindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1ClusterRoleListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1ClusterRoleList Method for WatchCloudStreamnativeIoV1alpha1ClusterRoleList

watch individual changes to a list of ClusterRole. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ClusterRoleList(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ClusterRoleListExecute(r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1ClusterRoleList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/clusterroles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1ClusterRoleStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1ClusterRoleStatus Method for WatchCloudStreamnativeIoV1alpha1ClusterRoleStatus

watch changes to status of an object of kind ClusterRole. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ClusterRole
 @return ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ClusterRoleStatus(ctx context.Context, name string) ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ClusterRoleStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1ClusterRoleStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1ClusterRoleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/clusterroles/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespaces

watch individual changes to a list of IdentityPool. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1IdentityPoolListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/identitypools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedAPIKey Method for WatchCloudStreamnativeIoV1alpha1NamespacedAPIKey

watch changes to an object of kind APIKey. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the APIKey
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedAPIKey(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedAPIKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/apikeys/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyList Method for WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyList

watch individual changes to a list of APIKey. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/apikeys"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus

watch changes to status of an object of kind APIKey. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the APIKey
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedAPIKeyStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/apikeys/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnection Method for WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnection

watch changes to an object of kind CloudConnection. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudConnection
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnection(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/cloudconnections/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionList Method for WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionList

watch individual changes to a list of CloudConnection. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/cloudconnections"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus

watch changes to status of an object of kind CloudConnection. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudConnection
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedCloudConnectionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/cloudconnections/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment Method for WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment

watch changes to an object of kind CloudEnvironment. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudEnvironment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/cloudenvironments/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentList Method for WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentList

watch individual changes to a list of CloudEnvironment. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/cloudenvironments"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus

watch changes to status of an object of kind CloudEnvironment. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the CloudEnvironment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedCloudEnvironmentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/cloudenvironments/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPool Method for WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPool

watch changes to an object of kind IdentityPool. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IdentityPool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPool(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/identitypools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolList Method for WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolList

watch individual changes to a list of IdentityPool. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/identitypools"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus

watch changes to status of an object of kind IdentityPool. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the IdentityPool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedIdentityPoolStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/identitypools/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProvider Method for WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProvider

watch changes to an object of kind OIDCProvider. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the OIDCProvider
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProvider(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/oidcproviders/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderList Method for WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderList

watch individual changes to a list of OIDCProvider. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/oidcproviders"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus

watch changes to status of an object of kind OIDCProvider. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the OIDCProvider
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedOIDCProviderStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/oidcproviders/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPool Method for WatchCloudStreamnativeIoV1alpha1NamespacedPool

watch changes to an object of kind Pool. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Pool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPool(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPool")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pools/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPoolList Method for WatchCloudStreamnativeIoV1alpha1NamespacedPoolList

watch individual changes to a list of Pool. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pools"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPoolMember Method for WatchCloudStreamnativeIoV1alpha1NamespacedPoolMember

watch changes to an object of kind PoolMember. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolMember
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolMember(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolMember")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/poolmembers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberList Method for WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberList

watch individual changes to a list of PoolMember. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/poolmembers"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus

watch changes to status of an object of kind PoolMember. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolMember
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolMemberStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/poolmembers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPoolOption Method for WatchCloudStreamnativeIoV1alpha1NamespacedPoolOption

watch changes to an object of kind PoolOption. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolOption
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolOption(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pooloptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionList Method for WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionList

watch individual changes to a list of PoolOption. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pooloptions"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus

watch changes to status of an object of kind PoolOption. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PoolOption
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolOptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pooloptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPoolStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedPoolStatus

watch changes to status of an object of kind Pool. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Pool
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPoolStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPoolStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pools/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPulsarCluster Method for WatchCloudStreamnativeIoV1alpha1NamespacedPulsarCluster

watch changes to an object of kind PulsarCluster. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarCluster
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarCluster(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pulsarclusters/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterList Method for WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterList

watch individual changes to a list of PulsarCluster. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pulsarclusters"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus

watch changes to status of an object of kind PulsarCluster. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarCluster
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarClusterStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pulsarclusters/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGateway Method for WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGateway

watch changes to an object of kind PulsarGateway. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarGateway
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGateway(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pulsargateways/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayList Method for WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayList

watch individual changes to a list of PulsarGateway. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pulsargateways"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus

watch changes to status of an object of kind PulsarGateway. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarGateway
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarGatewayStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pulsargateways/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstance Method for WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstance

watch changes to an object of kind PulsarInstance. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarInstance
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstance(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pulsarinstances/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceList Method for WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceList

watch individual changes to a list of PulsarInstance. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pulsarinstances"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus

watch changes to status of an object of kind PulsarInstance. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PulsarInstance
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedPulsarInstanceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/pulsarinstances/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedRole Method for WatchCloudStreamnativeIoV1alpha1NamespacedRole

watch changes to an object of kind Role. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Role
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedRole(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedRoleExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedRole")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/roles/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedRoleBinding Method for WatchCloudStreamnativeIoV1alpha1NamespacedRoleBinding

watch changes to an object of kind RoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the RoleBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedRoleBinding(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedRoleBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/rolebindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingList Method for WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingList

watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/rolebindings"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus

watch changes to status of an object of kind RoleBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the RoleBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedRoleBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/rolebindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedRoleListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedRoleList Method for WatchCloudStreamnativeIoV1alpha1NamespacedRoleList

watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedRoleList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedRoleListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedRoleList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/roles"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedRoleStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedRoleStatus

watch changes to status of an object of kind Role. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Role
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedRoleStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedRoleStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedRoleStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/roles/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedSecret Method for WatchCloudStreamnativeIoV1alpha1NamespacedSecret

watch changes to an object of kind Secret. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Secret
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedSecret(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedSecretExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedSecret")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/secrets/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedSecretListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedSecretList Method for WatchCloudStreamnativeIoV1alpha1NamespacedSecretList

watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedSecretList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedSecretListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedSecretList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedSecretStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedSecretStatus

watch changes to status of an object of kind Secret. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Secret
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedSecretStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedSecretStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedSecretStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/secrets/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccount Method for WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccount

watch changes to an object of kind ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccount(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/serviceaccounts/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding Method for WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding

watch changes to an object of kind ServiceAccountBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccountBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBinding")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/serviceaccountbindings/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingList Method for WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingList

watch individual changes to a list of ServiceAccountBinding. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/serviceaccountbindings"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus

watch changes to status of an object of kind ServiceAccountBinding. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccountBinding
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountBindingStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/serviceaccountbindings/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountList Method for WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountList

watch individual changes to a list of ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/serviceaccounts"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus

watch changes to status of an object of kind ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the ServiceAccount
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedServiceAccountStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/serviceaccounts/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscription Method for WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscription

watch changes to an object of kind StripeSubscription. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the StripeSubscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscription(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/stripesubscriptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionList Method for WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionList

watch individual changes to a list of StripeSubscription. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/stripesubscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus

watch changes to status of an object of kind StripeSubscription. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the StripeSubscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedStripeSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/stripesubscriptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedUserExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedUser Method for WatchCloudStreamnativeIoV1alpha1NamespacedUser

watch changes to an object of kind User. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the User
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedUser(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedUserExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/users/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedUserListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedUserList Method for WatchCloudStreamnativeIoV1alpha1NamespacedUserList

watch individual changes to a list of User. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedUserList(ctx context.Context, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedUserListExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedUserList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedUserStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1NamespacedUserStatus Method for WatchCloudStreamnativeIoV1alpha1NamespacedUserStatus

watch changes to status of an object of kind User. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the User
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedUserStatus(ctx context.Context, name string, namespace string) ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1NamespacedUserStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1NamespacedUserStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1NamespacedUserStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/namespaces/{namespace}/users/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespaces

watch individual changes to a list of OIDCProvider. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1OIDCProviderListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/oidcproviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1OrganizationExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1Organization Method for WatchCloudStreamnativeIoV1alpha1Organization

watch changes to an object of kind Organization. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Organization
 @return ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1Organization(ctx context.Context, name string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1OrganizationExecute(r ApiWatchCloudStreamnativeIoV1alpha1OrganizationRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1Organization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/organizations/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1OrganizationListExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1OrganizationList Method for WatchCloudStreamnativeIoV1alpha1OrganizationList

watch individual changes to a list of Organization. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1OrganizationList(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1OrganizationListExecute(r ApiWatchCloudStreamnativeIoV1alpha1OrganizationListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1OrganizationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	name string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1OrganizationStatusExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1OrganizationStatus Method for WatchCloudStreamnativeIoV1alpha1OrganizationStatus

watch changes to status of an object of kind Organization. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Organization
 @return ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1OrganizationStatus(ctx context.Context, name string) ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1OrganizationStatusExecute(r ApiWatchCloudStreamnativeIoV1alpha1OrganizationStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1OrganizationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/organizations/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1PoolListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1PoolListForAllNamespaces

watch individual changes to a list of Pool. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1PoolListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1PoolListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1PoolListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespaces

watch individual changes to a list of PoolMember. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1PoolMemberListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/poolmembers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespaces

watch individual changes to a list of PoolOption. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1PoolOptionListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/pooloptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespaces

watch individual changes to a list of PulsarCluster. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1PulsarClusterListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/pulsarclusters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespaces

watch individual changes to a list of PulsarGateway. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1PulsarGatewayListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/pulsargateways"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespaces

watch individual changes to a list of PulsarInstance. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1PulsarInstanceListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/pulsarinstances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespaces

watch individual changes to a list of RoleBinding. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1RoleBindingListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/rolebindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1RoleListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1RoleListForAllNamespaces

watch individual changes to a list of Role. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1RoleListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1RoleListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1RoleListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/roles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1SecretListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1SecretListForAllNamespaces

watch individual changes to a list of Secret. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1SecretListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1SecretListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1SecretListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/secrets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespaces

watch individual changes to a list of ServiceAccountBinding. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1ServiceAccountBindingListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/serviceaccountbindings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespaces

watch individual changes to a list of ServiceAccount. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1ServiceAccountListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/serviceaccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespaces

watch individual changes to a list of StripeSubscription. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1StripeSubscriptionListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/stripesubscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *CloudStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest) Limit(limit int32) ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest) Pretty(pretty string) ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest) Watch(watch bool) ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesExecute(r)
}

/*
WatchCloudStreamnativeIoV1alpha1UserListForAllNamespaces Method for WatchCloudStreamnativeIoV1alpha1UserListForAllNamespaces

watch individual changes to a list of User. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest
*/
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1UserListForAllNamespaces(ctx context.Context) ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest {
	return ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *CloudStreamnativeIoV1alpha1ApiService) WatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesExecute(r ApiWatchCloudStreamnativeIoV1alpha1UserListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudStreamnativeIoV1alpha1ApiService.WatchCloudStreamnativeIoV1alpha1UserListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/cloud.streamnative.io/v1alpha1/watch/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
