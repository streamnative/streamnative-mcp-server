//
// Copyright Â© 2023-2024 StreamNative Inc.
//

/*
Api

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sncloud

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ComputeStreamnativeIoV1alpha1ApiService ComputeStreamnativeIoV1alpha1Api service
type ComputeStreamnativeIoV1alpha1ApiService service

type ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment) ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Pretty(pretty string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) DryRun(dryRun string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) FieldManager(fieldManager string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	return r.ApiService.CreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r)
}

/*
CreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment Method for CreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment

create a FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) CreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment(ctx context.Context, namespace string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	return ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
func (a *ComputeStreamnativeIoV1alpha1ApiService) CreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.CreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/flinkdeployments"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment) ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Pretty(pretty string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) DryRun(dryRun string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) FieldManager(fieldManager string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	return r.ApiService.CreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusExecute(r)
}

/*
CreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus Method for CreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus

create status of a FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the FlinkDeployment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) CreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus(ctx context.Context, name string, namespace string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	return ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
func (a *ComputeStreamnativeIoV1alpha1ApiService) CreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusExecute(r ApiCreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.CreateComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/flinkdeployments/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace) ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Pretty(pretty string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) DryRun(dryRun string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) FieldManager(fieldManager string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	return r.ApiService.CreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r)
}

/*
CreateComputeStreamnativeIoV1alpha1NamespacedWorkspace Method for CreateComputeStreamnativeIoV1alpha1NamespacedWorkspace

create a Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) CreateComputeStreamnativeIoV1alpha1NamespacedWorkspace(ctx context.Context, namespace string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	return ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
func (a *ComputeStreamnativeIoV1alpha1ApiService) CreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.CreateComputeStreamnativeIoV1alpha1NamespacedWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/workspaces"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace) ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Pretty(pretty string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) DryRun(dryRun string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) FieldManager(fieldManager string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	return r.ApiService.CreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusExecute(r)
}

/*
CreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus Method for CreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus

create status of a Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Workspace
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) CreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus(ctx context.Context, name string, namespace string) ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	return ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
func (a *ComputeStreamnativeIoV1alpha1ApiService) CreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusExecute(r ApiCreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.CreateComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/workspaces/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) Pretty(pretty string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) Continue_(continue_ string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) DryRun(dryRun string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) FieldSelector(fieldSelector string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) LabelSelector(labelSelector string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) Limit(limit int32) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) OrphanDependents(orphanDependents bool) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) PropagationPolicy(propagationPolicy string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) ResourceVersion(resourceVersion string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) Body(body V1DeleteOptions) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	r.body = &body
	return r
}

func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentExecute(r)
}

/*
DeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeployment Method for DeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeployment

delete collection of FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) DeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeployment(ctx context.Context, namespace string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest {
	return ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *ComputeStreamnativeIoV1alpha1ApiService) DeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentExecute(r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeploymentRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.DeleteComputeStreamnativeIoV1alpha1CollectionNamespacedFlinkDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/flinkdeployments"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) Pretty(pretty string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) Continue_(continue_ string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) DryRun(dryRun string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) FieldSelector(fieldSelector string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) LabelSelector(labelSelector string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) Limit(limit int32) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) OrphanDependents(orphanDependents bool) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) PropagationPolicy(propagationPolicy string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) ResourceVersion(resourceVersion string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) Body(body V1DeleteOptions) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	r.body = &body
	return r
}

func (r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceExecute(r)
}

/*
DeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspace Method for DeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspace

delete collection of Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) DeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspace(ctx context.Context, namespace string) ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest {
	return ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *ComputeStreamnativeIoV1alpha1ApiService) DeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceExecute(r ApiDeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspaceRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.DeleteComputeStreamnativeIoV1alpha1CollectionNamespacedWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/workspaces"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Pretty(pretty string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) DryRun(dryRun string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) OrphanDependents(orphanDependents bool) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) PropagationPolicy(propagationPolicy string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Body(body V1DeleteOptions) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.body = &body
	return r
}

func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r)
}

/*
DeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment Method for DeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment

delete a FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the FlinkDeployment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) DeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment(ctx context.Context, name string, namespace string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	return ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *ComputeStreamnativeIoV1alpha1ApiService) DeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.DeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/flinkdeployments/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Pretty(pretty string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) DryRun(dryRun string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Body(body V1DeleteOptions) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusExecute(r)
}

/*
DeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus Method for DeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus

delete status of a FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the FlinkDeployment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) DeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus(ctx context.Context, name string, namespace string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	return ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *ComputeStreamnativeIoV1alpha1ApiService) DeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusExecute(r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.DeleteComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/flinkdeployments/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Pretty(pretty string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) DryRun(dryRun string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) OrphanDependents(orphanDependents bool) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) PropagationPolicy(propagationPolicy string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Body(body V1DeleteOptions) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.body = &body
	return r
}

func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r)
}

/*
DeleteComputeStreamnativeIoV1alpha1NamespacedWorkspace Method for DeleteComputeStreamnativeIoV1alpha1NamespacedWorkspace

delete a Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Workspace
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) DeleteComputeStreamnativeIoV1alpha1NamespacedWorkspace(ctx context.Context, name string, namespace string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	return ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *ComputeStreamnativeIoV1alpha1ApiService) DeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.DeleteComputeStreamnativeIoV1alpha1NamespacedWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/workspaces/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Pretty(pretty string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) DryRun(dryRun string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Body(body V1DeleteOptions) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusExecute(r)
}

/*
DeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus Method for DeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus

delete status of a Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Workspace
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) DeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus(ctx context.Context, name string, namespace string) ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	return ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *ComputeStreamnativeIoV1alpha1ApiService) DeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusExecute(r ApiDeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.DeleteComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/workspaces/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetComputeStreamnativeIoV1alpha1APIResourcesRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
}

func (r ApiGetComputeStreamnativeIoV1alpha1APIResourcesRequest) Execute() (*V1APIResourceList, *http.Response, error) {
	return r.ApiService.GetComputeStreamnativeIoV1alpha1APIResourcesExecute(r)
}

/*
GetComputeStreamnativeIoV1alpha1APIResources Method for GetComputeStreamnativeIoV1alpha1APIResources

get available resources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetComputeStreamnativeIoV1alpha1APIResourcesRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) GetComputeStreamnativeIoV1alpha1APIResources(ctx context.Context) ApiGetComputeStreamnativeIoV1alpha1APIResourcesRequest {
	return ApiGetComputeStreamnativeIoV1alpha1APIResourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1APIResourceList
func (a *ComputeStreamnativeIoV1alpha1ApiService) GetComputeStreamnativeIoV1alpha1APIResourcesExecute(r ApiGetComputeStreamnativeIoV1alpha1APIResourcesRequest) (*V1APIResourceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1APIResourceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.GetComputeStreamnativeIoV1alpha1APIResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest) Continue_(continue_ string) ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest) Limit(limit int32) ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest) Pretty(pretty string) ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest) Watch(watch bool) ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeploymentList, *http.Response, error) {
	return r.ApiService.ListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesExecute(r)
}

/*
ListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespaces Method for ListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespaces

list or watch objects of kind FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) ListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespaces(ctx context.Context) ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest {
	return ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeploymentList
func (a *ComputeStreamnativeIoV1alpha1ApiService) ListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesExecute(r ApiListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeploymentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeploymentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.ListComputeStreamnativeIoV1alpha1FlinkDeploymentForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/flinkdeployments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Pretty(pretty string) ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Continue_(continue_ string) ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) FieldSelector(fieldSelector string) ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) LabelSelector(labelSelector string) ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Limit(limit int32) ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) ResourceVersion(resourceVersion string) ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) TimeoutSeconds(timeoutSeconds int32) ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Watch(watch bool) ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.watch = &watch
	return r
}

func (r ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeploymentList, *http.Response, error) {
	return r.ApiService.ListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r)
}

/*
ListComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment Method for ListComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment

list or watch objects of kind FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) ListComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment(ctx context.Context, namespace string) ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	return ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeploymentList
func (a *ComputeStreamnativeIoV1alpha1ApiService) ListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r ApiListComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeploymentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeploymentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.ListComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/flinkdeployments"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Pretty(pretty string) ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Continue_(continue_ string) ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) FieldSelector(fieldSelector string) ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) LabelSelector(labelSelector string) ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Limit(limit int32) ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) ResourceVersion(resourceVersion string) ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) TimeoutSeconds(timeoutSeconds int32) ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Watch(watch bool) ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.watch = &watch
	return r
}

func (r ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1WorkspaceList, *http.Response, error) {
	return r.ApiService.ListComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r)
}

/*
ListComputeStreamnativeIoV1alpha1NamespacedWorkspace Method for ListComputeStreamnativeIoV1alpha1NamespacedWorkspace

list or watch objects of kind Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) ListComputeStreamnativeIoV1alpha1NamespacedWorkspace(ctx context.Context, namespace string) ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	return ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1WorkspaceList
func (a *ComputeStreamnativeIoV1alpha1ApiService) ListComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r ApiListComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1WorkspaceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1WorkspaceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.ListComputeStreamnativeIoV1alpha1NamespacedWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/workspaces"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest) Continue_(continue_ string) ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest) Limit(limit int32) ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest) Pretty(pretty string) ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest) Watch(watch bool) ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1WorkspaceList, *http.Response, error) {
	return r.ApiService.ListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesExecute(r)
}

/*
ListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespaces Method for ListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespaces

list or watch objects of kind Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) ListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespaces(ctx context.Context) ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest {
	return ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1WorkspaceList
func (a *ComputeStreamnativeIoV1alpha1ApiService) ListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesExecute(r ApiListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1WorkspaceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1WorkspaceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.ListComputeStreamnativeIoV1alpha1WorkspaceForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/workspaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Body(body map[string]interface{}) ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Pretty(pretty string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) DryRun(dryRun string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) FieldManager(fieldManager string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Force(force bool) ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.force = &force
	return r
}

func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	return r.ApiService.PatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r)
}

/*
PatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment Method for PatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment

partially update the specified FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the FlinkDeployment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) PatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment(ctx context.Context, name string, namespace string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	return ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
func (a *ComputeStreamnativeIoV1alpha1ApiService) PatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.PatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/flinkdeployments/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Body(body map[string]interface{}) ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Pretty(pretty string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) DryRun(dryRun string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) FieldManager(fieldManager string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Force(force bool) ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	return r.ApiService.PatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusExecute(r)
}

/*
PatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus Method for PatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus

partially update status of the specified FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the FlinkDeployment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) PatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus(ctx context.Context, name string, namespace string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	return ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
func (a *ComputeStreamnativeIoV1alpha1ApiService) PatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusExecute(r ApiPatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.PatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/flinkdeployments/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Body(body map[string]interface{}) ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Pretty(pretty string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) DryRun(dryRun string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) FieldManager(fieldManager string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Force(force bool) ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.force = &force
	return r
}

func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	return r.ApiService.PatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r)
}

/*
PatchComputeStreamnativeIoV1alpha1NamespacedWorkspace Method for PatchComputeStreamnativeIoV1alpha1NamespacedWorkspace

partially update the specified Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Workspace
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) PatchComputeStreamnativeIoV1alpha1NamespacedWorkspace(ctx context.Context, name string, namespace string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	return ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
func (a *ComputeStreamnativeIoV1alpha1ApiService) PatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.PatchComputeStreamnativeIoV1alpha1NamespacedWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/workspaces/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Body(body map[string]interface{}) ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Pretty(pretty string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) DryRun(dryRun string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) FieldManager(fieldManager string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Force(force bool) ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	return r.ApiService.PatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusExecute(r)
}

/*
PatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus Method for PatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus

partially update status of the specified Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Workspace
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) PatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus(ctx context.Context, name string, namespace string) ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	return ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
func (a *ComputeStreamnativeIoV1alpha1ApiService) PatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusExecute(r ApiPatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.PatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/workspaces/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Pretty(pretty string) ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	return r.ApiService.ReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r)
}

/*
ReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment Method for ReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment

read the specified FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the FlinkDeployment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment(ctx context.Context, name string, namespace string) ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	return ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.ReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/flinkdeployments/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Pretty(pretty string) ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	return r.ApiService.ReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusExecute(r)
}

/*
ReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus Method for ReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus

read status of the specified FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the FlinkDeployment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus(ctx context.Context, name string, namespace string) ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	return ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusExecute(r ApiReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.ReadComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/flinkdeployments/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Pretty(pretty string) ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	return r.ApiService.ReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r)
}

/*
ReadComputeStreamnativeIoV1alpha1NamespacedWorkspace Method for ReadComputeStreamnativeIoV1alpha1NamespacedWorkspace

read the specified Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Workspace
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReadComputeStreamnativeIoV1alpha1NamespacedWorkspace(ctx context.Context, name string, namespace string) ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	return ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.ReadComputeStreamnativeIoV1alpha1NamespacedWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/workspaces/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Pretty(pretty string) ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	return r.ApiService.ReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusExecute(r)
}

/*
ReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus Method for ReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus

read status of the specified Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Workspace
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus(ctx context.Context, name string, namespace string) ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	return ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusExecute(r ApiReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.ReadComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/workspaces/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Pretty(pretty string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) DryRun(dryRun string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) FieldManager(fieldManager string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	return r.ApiService.ReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r)
}

/*
ReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment Method for ReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment

replace the specified FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the FlinkDeployment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment(ctx context.Context, name string, namespace string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	return ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.ReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/flinkdeployments/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Pretty(pretty string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) DryRun(dryRun string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) FieldManager(fieldManager string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	return r.ApiService.ReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusExecute(r)
}

/*
ReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus Method for ReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus

replace status of the specified FlinkDeployment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the FlinkDeployment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus(ctx context.Context, name string, namespace string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	return ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusExecute(r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1FlinkDeployment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.ReplaceComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/flinkdeployments/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Pretty(pretty string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) DryRun(dryRun string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) FieldManager(fieldManager string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	return r.ApiService.ReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r)
}

/*
ReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspace Method for ReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspace

replace the specified Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Workspace
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspace(ctx context.Context, name string, namespace string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	return ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.ReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/workspaces/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Pretty(pretty string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) DryRun(dryRun string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) FieldManager(fieldManager string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	return r.ApiService.ReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusExecute(r)
}

/*
ReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus Method for ReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus

replace status of the specified Workspace

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Workspace
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus(ctx context.Context, name string, namespace string) ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	return ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
func (a *ComputeStreamnativeIoV1alpha1ApiService) ReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusExecute(r ApiReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisComputeV1alpha1Workspace
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.ReplaceComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/namespaces/{namespace}/workspaces/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest) Limit(limit int32) ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest) Pretty(pretty string) ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest) Watch(watch bool) ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesExecute(r)
}

/*
WatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespaces Method for WatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespaces

watch individual changes to a list of FlinkDeployment. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespaces(ctx context.Context) ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest {
	return ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesExecute(r ApiWatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.WatchComputeStreamnativeIoV1alpha1FlinkDeploymentListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/watch/flinkdeployments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Continue_(continue_ string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) FieldSelector(fieldSelector string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) LabelSelector(labelSelector string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Limit(limit int32) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Pretty(pretty string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) ResourceVersion(resourceVersion string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Watch(watch bool) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r)
}

/*
WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment Method for WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment

watch changes to an object of kind FlinkDeployment. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the FlinkDeployment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment(ctx context.Context, name string, namespace string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest {
	return ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentExecute(r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeployment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/watch/namespaces/{namespace}/flinkdeployments/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest) Continue_(continue_ string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest) FieldSelector(fieldSelector string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest) LabelSelector(labelSelector string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest) Limit(limit int32) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest) Pretty(pretty string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest) ResourceVersion(resourceVersion string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest) Watch(watch bool) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListExecute(r)
}

/*
WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentList Method for WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentList

watch individual changes to a list of FlinkDeployment. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentList(ctx context.Context, namespace string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest {
	return ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListExecute(r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/watch/namespaces/{namespace}/flinkdeployments"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Continue_(continue_ string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) FieldSelector(fieldSelector string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) LabelSelector(labelSelector string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Limit(limit int32) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Pretty(pretty string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) ResourceVersion(resourceVersion string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Watch(watch bool) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusExecute(r)
}

/*
WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus Method for WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus

watch changes to status of an object of kind FlinkDeployment. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the FlinkDeployment
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus(ctx context.Context, name string, namespace string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest {
	return ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusExecute(r ApiWatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.WatchComputeStreamnativeIoV1alpha1NamespacedFlinkDeploymentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/watch/namespaces/{namespace}/flinkdeployments/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Continue_(continue_ string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) FieldSelector(fieldSelector string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) LabelSelector(labelSelector string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Limit(limit int32) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Pretty(pretty string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) ResourceVersion(resourceVersion string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Watch(watch bool) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r)
}

/*
WatchComputeStreamnativeIoV1alpha1NamespacedWorkspace Method for WatchComputeStreamnativeIoV1alpha1NamespacedWorkspace

watch changes to an object of kind Workspace. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Workspace
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1NamespacedWorkspace(ctx context.Context, name string, namespace string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest {
	return ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceExecute(r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.WatchComputeStreamnativeIoV1alpha1NamespacedWorkspace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/watch/namespaces/{namespace}/workspaces/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest) Continue_(continue_ string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest) FieldSelector(fieldSelector string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest) LabelSelector(labelSelector string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest) Limit(limit int32) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest) Pretty(pretty string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest) ResourceVersion(resourceVersion string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest) Watch(watch bool) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListExecute(r)
}

/*
WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceList Method for WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceList

watch individual changes to a list of Workspace. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceList(ctx context.Context, namespace string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest {
	return ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListExecute(r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/watch/namespaces/{namespace}/workspaces"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Continue_(continue_ string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) FieldSelector(fieldSelector string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) LabelSelector(labelSelector string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Limit(limit int32) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Pretty(pretty string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) ResourceVersion(resourceVersion string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Watch(watch bool) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusExecute(r)
}

/*
WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus Method for WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus

watch changes to status of an object of kind Workspace. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Workspace
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus(ctx context.Context, name string, namespace string) ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest {
	return ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusExecute(r ApiWatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.WatchComputeStreamnativeIoV1alpha1NamespacedWorkspaceStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/watch/namespaces/{namespace}/workspaces/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *ComputeStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest) Limit(limit int32) ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest) Pretty(pretty string) ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest) Watch(watch bool) ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesExecute(r)
}

/*
WatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespaces Method for WatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespaces

watch individual changes to a list of Workspace. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest
*/
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespaces(ctx context.Context) ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest {
	return ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *ComputeStreamnativeIoV1alpha1ApiService) WatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesExecute(r ApiWatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ComputeStreamnativeIoV1alpha1ApiService.WatchComputeStreamnativeIoV1alpha1WorkspaceListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/compute.streamnative.io/v1alpha1/watch/workspaces"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
