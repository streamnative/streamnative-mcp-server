//
// Copyright Â© 2023-2024 StreamNative Inc.
//

/*
Api

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sncloud

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// BillingStreamnativeIoV1alpha1ApiService BillingStreamnativeIoV1alpha1Api service
type BillingStreamnativeIoV1alpha1ApiService service

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1CustomerPortalRequest
	dryRun *string
	fieldManager *string
	pretty *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1CustomerPortalRequest) ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest {
	r.body = &body
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest {
	r.fieldManager = &fieldManager
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest {
	r.pretty = &pretty
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1CustomerPortalRequest, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequest Method for CreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequest

create a CustomerPortalRequest

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequest(ctx context.Context, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1CustomerPortalRequest
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequestRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1CustomerPortalRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1CustomerPortalRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedCustomerPortalRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/customerportalrequests"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntent Method for CreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntent

create a PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntent(ctx context.Context, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/paymentintents"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus Method for CreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus

create status of a PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PaymentIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus(ctx context.Context, name string, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/paymentintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedPrivateOffer Method for CreateBillingStreamnativeIoV1alpha1NamespacedPrivateOffer

create a PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedPrivateOffer(ctx context.Context, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedPrivateOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/privateoffers"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus Method for CreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus

create status of a PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PrivateOffer
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus(ctx context.Context, name string, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/privateoffers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product) ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedProductExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedProduct Method for CreateBillingStreamnativeIoV1alpha1NamespacedProduct

create a Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedProduct(ctx context.Context, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedProductExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/products"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product) ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedProductStatusExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedProductStatus Method for CreateBillingStreamnativeIoV1alpha1NamespacedProductStatus

create status of a Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Product
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedProductStatus(ctx context.Context, name string, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedProductStatusExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedProductStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/products/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedSetupIntent Method for CreateBillingStreamnativeIoV1alpha1NamespacedSetupIntent

create a SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedSetupIntent(ctx context.Context, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedSetupIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/setupintents"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus Method for CreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus

create status of a SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SetupIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus(ctx context.Context, name string, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/setupintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedSubscription Method for CreateBillingStreamnativeIoV1alpha1NamespacedSubscription

create a Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedSubscription(ctx context.Context, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent Method for CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent

create a SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent(ctx context.Context, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptionintents"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus Method for CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus

create status of a SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SubscriptionIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus(ctx context.Context, name string, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptionintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus Method for CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus

create status of a Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Subscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus(ctx context.Context, name string, namespace string) ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusExecute(r ApiCreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer) ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1PublicOfferExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1PublicOffer Method for CreateBillingStreamnativeIoV1alpha1PublicOffer

create a PublicOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1PublicOffer(ctx context.Context) ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1PublicOfferExecute(r ApiCreateBillingStreamnativeIoV1alpha1PublicOfferRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1PublicOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/publicoffers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer) ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1PublicOfferStatusExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1PublicOfferStatus Method for CreateBillingStreamnativeIoV1alpha1PublicOfferStatus

create status of a PublicOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PublicOffer
 @return ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1PublicOfferStatus(ctx context.Context, name string) ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1PublicOfferStatusExecute(r ApiCreateBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1PublicOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/publicoffers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SugerEntitlementReview
	dryRun *string
	fieldManager *string
	pretty *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SugerEntitlementReview) ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest {
	r.body = &body
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest {
	r.fieldManager = &fieldManager
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest {
	r.pretty = &pretty
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SugerEntitlementReview, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1SugerEntitlementReview Method for CreateBillingStreamnativeIoV1alpha1SugerEntitlementReview

create a SugerEntitlementReview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1SugerEntitlementReview(ctx context.Context) ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SugerEntitlementReview
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewExecute(r ApiCreateBillingStreamnativeIoV1alpha1SugerEntitlementReviewRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SugerEntitlementReview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SugerEntitlementReview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1SugerEntitlementReview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/sugerentitlementreviews"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock) ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1TestClockExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1TestClock Method for CreateBillingStreamnativeIoV1alpha1TestClock

create a TestClock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1TestClock(ctx context.Context) ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1TestClockExecute(r ApiCreateBillingStreamnativeIoV1alpha1TestClockRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1TestClock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/testclocks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock) ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest) Pretty(pretty string) ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest) DryRun(dryRun string) ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest) FieldManager(fieldManager string) ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	return r.ApiService.CreateBillingStreamnativeIoV1alpha1TestClockStatusExecute(r)
}

/*
CreateBillingStreamnativeIoV1alpha1TestClockStatus Method for CreateBillingStreamnativeIoV1alpha1TestClockStatus

create status of a TestClock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the TestClock
 @return ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1TestClockStatus(ctx context.Context, name string) ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	return ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
func (a *BillingStreamnativeIoV1alpha1ApiService) CreateBillingStreamnativeIoV1alpha1TestClockStatusExecute(r ApiCreateBillingStreamnativeIoV1alpha1TestClockStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.CreateBillingStreamnativeIoV1alpha1TestClockStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/testclocks/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) Continue_(continue_ string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) FieldSelector(fieldSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) LabelSelector(labelSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) Limit(limit int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) ResourceVersion(resourceVersion string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntent Method for DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntent

delete collection of PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntent(ctx context.Context, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentExecute(r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntentRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPaymentIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/paymentintents"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) Continue_(continue_ string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) FieldSelector(fieldSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) LabelSelector(labelSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) Limit(limit int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) ResourceVersion(resourceVersion string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOffer Method for DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOffer

delete collection of PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOffer(ctx context.Context, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferExecute(r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOfferRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedPrivateOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/privateoffers"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) Continue_(continue_ string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) FieldSelector(fieldSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) LabelSelector(labelSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) Limit(limit int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) ResourceVersion(resourceVersion string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProduct Method for DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProduct

delete collection of Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProduct(ctx context.Context, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductExecute(r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProductRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/products"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) Continue_(continue_ string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) FieldSelector(fieldSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) LabelSelector(labelSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) Limit(limit int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) ResourceVersion(resourceVersion string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntent Method for DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntent

delete collection of SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntent(ctx context.Context, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentExecute(r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntentRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSetupIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/setupintents"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) Continue_(continue_ string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) FieldSelector(fieldSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) LabelSelector(labelSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) Limit(limit int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) ResourceVersion(resourceVersion string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscription Method for DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscription

delete collection of Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscription(ctx context.Context, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionExecute(r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) Continue_(continue_ string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) FieldSelector(fieldSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) LabelSelector(labelSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) Limit(limit int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) ResourceVersion(resourceVersion string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntent Method for DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntent

delete collection of SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntent(ctx context.Context, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentExecute(r ApiDeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntentRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionNamespacedSubscriptionIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptionintents"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) Continue_(continue_ string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) FieldSelector(fieldSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) LabelSelector(labelSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) Limit(limit int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) ResourceVersion(resourceVersion string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1CollectionPublicOffer Method for DeleteBillingStreamnativeIoV1alpha1CollectionPublicOffer

delete collection of PublicOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionPublicOffer(ctx context.Context) ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferExecute(r ApiDeleteBillingStreamnativeIoV1alpha1CollectionPublicOfferRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionPublicOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/publicoffers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	pretty *string
	continue_ *string
	dryRun *string
	fieldSelector *string
	gracePeriodSeconds *int32
	labelSelector *string
	limit *int32
	orphanDependents *bool
	propagationPolicy *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.pretty = &pretty
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) Continue_(continue_ string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.continue_ = &continue_
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.dryRun = &dryRun
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) FieldSelector(fieldSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) LabelSelector(labelSelector string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) Limit(limit int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.limit = &limit
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) ResourceVersion(resourceVersion string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) ResourceVersionMatch(resourceVersionMatch string) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) TimeoutSeconds(timeoutSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionTestClockExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1CollectionTestClock Method for DeleteBillingStreamnativeIoV1alpha1CollectionTestClock

delete collection of TestClock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionTestClock(ctx context.Context) ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1CollectionTestClockExecute(r ApiDeleteBillingStreamnativeIoV1alpha1CollectionTestClockRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1CollectionTestClock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/testclocks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntent Method for DeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntent

delete a PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PaymentIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntent(ctx context.Context, name string, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/paymentintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus Method for DeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus

delete status of a PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PaymentIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus(ctx context.Context, name string, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusExecute(r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/paymentintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOffer Method for DeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOffer

delete a PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PrivateOffer
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOffer(ctx context.Context, name string, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/privateoffers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus Method for DeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus

delete status of a PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PrivateOffer
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus(ctx context.Context, name string, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusExecute(r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/privateoffers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedProductExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1NamespacedProduct Method for DeleteBillingStreamnativeIoV1alpha1NamespacedProduct

delete a Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Product
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedProduct(ctx context.Context, name string, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedProductExecute(r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/products/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1NamespacedProductStatus Method for DeleteBillingStreamnativeIoV1alpha1NamespacedProductStatus

delete status of a Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Product
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedProductStatus(ctx context.Context, name string, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusExecute(r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedProductStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/products/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntent Method for DeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntent

delete a SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SetupIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntent(ctx context.Context, name string, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/setupintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus Method for DeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus

delete status of a SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SetupIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus(ctx context.Context, name string, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusExecute(r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/setupintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1NamespacedSubscription Method for DeleteBillingStreamnativeIoV1alpha1NamespacedSubscription

delete a Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Subscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedSubscription(ctx context.Context, name string, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent Method for DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent

delete a SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SubscriptionIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent(ctx context.Context, name string, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptionintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus Method for DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus

delete status of a SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SubscriptionIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus(ctx context.Context, name string, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusExecute(r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptionintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus Method for DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus

delete status of a Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Subscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus(ctx context.Context, name string, namespace string) ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusExecute(r ApiDeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1PublicOfferExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1PublicOffer Method for DeleteBillingStreamnativeIoV1alpha1PublicOffer

delete a PublicOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PublicOffer
 @return ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1PublicOffer(ctx context.Context, name string) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1PublicOfferExecute(r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1PublicOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/publicoffers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1PublicOfferStatusExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1PublicOfferStatus Method for DeleteBillingStreamnativeIoV1alpha1PublicOfferStatus

delete status of a PublicOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PublicOffer
 @return ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1PublicOfferStatus(ctx context.Context, name string) ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1PublicOfferStatusExecute(r ApiDeleteBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1PublicOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/publicoffers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1TestClockExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1TestClock Method for DeleteBillingStreamnativeIoV1alpha1TestClock

delete a TestClock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the TestClock
 @return ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1TestClock(ctx context.Context, name string) ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1TestClockExecute(r ApiDeleteBillingStreamnativeIoV1alpha1TestClockRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1TestClock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/testclocks/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
	dryRun *string
	gracePeriodSeconds *int32
	orphanDependents *bool
	propagationPolicy *string
	body *V1DeleteOptions
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest) Pretty(pretty string) ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest) DryRun(dryRun string) ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.dryRun = &dryRun
	return r
}

// The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest) GracePeriodSeconds(gracePeriodSeconds int32) ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.gracePeriodSeconds = &gracePeriodSeconds
	return r
}

// Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest) OrphanDependents(orphanDependents bool) ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.orphanDependents = &orphanDependents
	return r
}

// Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest) PropagationPolicy(propagationPolicy string) ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.propagationPolicy = &propagationPolicy
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest) Body(body V1DeleteOptions) ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.body = &body
	return r
}

func (r ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest) Execute() (*V1Status, *http.Response, error) {
	return r.ApiService.DeleteBillingStreamnativeIoV1alpha1TestClockStatusExecute(r)
}

/*
DeleteBillingStreamnativeIoV1alpha1TestClockStatus Method for DeleteBillingStreamnativeIoV1alpha1TestClockStatus

delete status of a TestClock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the TestClock
 @return ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1TestClockStatus(ctx context.Context, name string) ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	return ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1Status
func (a *BillingStreamnativeIoV1alpha1ApiService) DeleteBillingStreamnativeIoV1alpha1TestClockStatusExecute(r ApiDeleteBillingStreamnativeIoV1alpha1TestClockStatusRequest) (*V1Status, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Status
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.DeleteBillingStreamnativeIoV1alpha1TestClockStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/testclocks/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.gracePeriodSeconds != nil {
		localVarQueryParams.Add("gracePeriodSeconds", parameterToString(*r.gracePeriodSeconds, ""))
	}
	if r.orphanDependents != nil {
		localVarQueryParams.Add("orphanDependents", parameterToString(*r.orphanDependents, ""))
	}
	if r.propagationPolicy != nil {
		localVarQueryParams.Add("propagationPolicy", parameterToString(*r.propagationPolicy, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBillingStreamnativeIoV1alpha1APIResourcesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
}

func (r ApiGetBillingStreamnativeIoV1alpha1APIResourcesRequest) Execute() (*V1APIResourceList, *http.Response, error) {
	return r.ApiService.GetBillingStreamnativeIoV1alpha1APIResourcesExecute(r)
}

/*
GetBillingStreamnativeIoV1alpha1APIResources Method for GetBillingStreamnativeIoV1alpha1APIResources

get available resources

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBillingStreamnativeIoV1alpha1APIResourcesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) GetBillingStreamnativeIoV1alpha1APIResources(ctx context.Context) ApiGetBillingStreamnativeIoV1alpha1APIResourcesRequest {
	return ApiGetBillingStreamnativeIoV1alpha1APIResourcesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1APIResourceList
func (a *BillingStreamnativeIoV1alpha1ApiService) GetBillingStreamnativeIoV1alpha1APIResourcesExecute(r ApiGetBillingStreamnativeIoV1alpha1APIResourcesRequest) (*V1APIResourceList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1APIResourceList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.GetBillingStreamnativeIoV1alpha1APIResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntentList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1NamespacedPaymentIntent Method for ListBillingStreamnativeIoV1alpha1NamespacedPaymentIntent

list or watch objects of kind PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1NamespacedPaymentIntent(ctx context.Context, namespace string) ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	return ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntentList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r ApiListBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1NamespacedPaymentIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/paymentintents"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOfferList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1NamespacedPrivateOffer Method for ListBillingStreamnativeIoV1alpha1NamespacedPrivateOffer

list or watch objects of kind PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1NamespacedPrivateOffer(ctx context.Context, namespace string) ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	return ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOfferList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r ApiListBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOfferList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOfferList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1NamespacedPrivateOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/privateoffers"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1ProductList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1NamespacedProductExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1NamespacedProduct Method for ListBillingStreamnativeIoV1alpha1NamespacedProduct

list or watch objects of kind Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1NamespacedProduct(ctx context.Context, namespace string) ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	return ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1ProductList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1NamespacedProductExecute(r ApiListBillingStreamnativeIoV1alpha1NamespacedProductRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1ProductList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1ProductList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1NamespacedProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/products"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntentList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1NamespacedSetupIntent Method for ListBillingStreamnativeIoV1alpha1NamespacedSetupIntent

list or watch objects of kind SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1NamespacedSetupIntent(ctx context.Context, namespace string) ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	return ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntentList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r ApiListBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1NamespacedSetupIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/setupintents"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1NamespacedSubscription Method for ListBillingStreamnativeIoV1alpha1NamespacedSubscription

list or watch objects of kind Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1NamespacedSubscription(ctx context.Context, namespace string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	return ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1NamespacedSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntentList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent Method for ListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent

list or watch objects of kind SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent(ctx context.Context, namespace string) ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	return ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntentList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r ApiListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptionintents"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntentList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespaces Method for ListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespaces

list or watch objects of kind PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespaces(ctx context.Context) ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest {
	return ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntentList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesExecute(r ApiListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1PaymentIntentForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/paymentintents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOfferList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespaces Method for ListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespaces

list or watch objects of kind PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespaces(ctx context.Context) ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest {
	return ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOfferList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesExecute(r ApiListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOfferList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOfferList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1PrivateOfferForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/privateoffers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1ProductList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1ProductForAllNamespacesExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1ProductForAllNamespaces Method for ListBillingStreamnativeIoV1alpha1ProductForAllNamespaces

list or watch objects of kind Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1ProductForAllNamespaces(ctx context.Context) ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest {
	return ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1ProductList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1ProductForAllNamespacesExecute(r ApiListBillingStreamnativeIoV1alpha1ProductForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1ProductList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1ProductList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1ProductForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOfferList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1PublicOfferExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1PublicOffer Method for ListBillingStreamnativeIoV1alpha1PublicOffer

list or watch objects of kind PublicOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1PublicOffer(ctx context.Context) ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest {
	return ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOfferList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1PublicOfferExecute(r ApiListBillingStreamnativeIoV1alpha1PublicOfferRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOfferList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOfferList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1PublicOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/publicoffers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntentList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespaces Method for ListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespaces

list or watch objects of kind SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespaces(ctx context.Context) ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest {
	return ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntentList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesExecute(r ApiListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1SetupIntentForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/setupintents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespaces Method for ListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespaces

list or watch objects of kind Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespaces(ctx context.Context) ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest {
	return ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesExecute(r ApiListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1SubscriptionForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntentList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespaces Method for ListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespaces

list or watch objects of kind SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespaces(ctx context.Context) ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest {
	return ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntentList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesExecute(r ApiListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespacesRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntentList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntentList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1SubscriptionIntentForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/subscriptionintents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingStreamnativeIoV1alpha1TestClockRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	pretty *string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiListBillingStreamnativeIoV1alpha1TestClockRequest) Pretty(pretty string) ApiListBillingStreamnativeIoV1alpha1TestClockRequest {
	r.pretty = &pretty
	return r
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiListBillingStreamnativeIoV1alpha1TestClockRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiListBillingStreamnativeIoV1alpha1TestClockRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiListBillingStreamnativeIoV1alpha1TestClockRequest) Continue_(continue_ string) ApiListBillingStreamnativeIoV1alpha1TestClockRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1TestClockRequest) FieldSelector(fieldSelector string) ApiListBillingStreamnativeIoV1alpha1TestClockRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiListBillingStreamnativeIoV1alpha1TestClockRequest) LabelSelector(labelSelector string) ApiListBillingStreamnativeIoV1alpha1TestClockRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiListBillingStreamnativeIoV1alpha1TestClockRequest) Limit(limit int32) ApiListBillingStreamnativeIoV1alpha1TestClockRequest {
	r.limit = &limit
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1TestClockRequest) ResourceVersion(resourceVersion string) ApiListBillingStreamnativeIoV1alpha1TestClockRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiListBillingStreamnativeIoV1alpha1TestClockRequest) ResourceVersionMatch(resourceVersionMatch string) ApiListBillingStreamnativeIoV1alpha1TestClockRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiListBillingStreamnativeIoV1alpha1TestClockRequest) TimeoutSeconds(timeoutSeconds int32) ApiListBillingStreamnativeIoV1alpha1TestClockRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiListBillingStreamnativeIoV1alpha1TestClockRequest) Watch(watch bool) ApiListBillingStreamnativeIoV1alpha1TestClockRequest {
	r.watch = &watch
	return r
}

func (r ApiListBillingStreamnativeIoV1alpha1TestClockRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClockList, *http.Response, error) {
	return r.ApiService.ListBillingStreamnativeIoV1alpha1TestClockExecute(r)
}

/*
ListBillingStreamnativeIoV1alpha1TestClock Method for ListBillingStreamnativeIoV1alpha1TestClock

list or watch objects of kind TestClock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingStreamnativeIoV1alpha1TestClockRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1TestClock(ctx context.Context) ApiListBillingStreamnativeIoV1alpha1TestClockRequest {
	return ApiListBillingStreamnativeIoV1alpha1TestClockRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClockList
func (a *BillingStreamnativeIoV1alpha1ApiService) ListBillingStreamnativeIoV1alpha1TestClockExecute(r ApiListBillingStreamnativeIoV1alpha1TestClockRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClockList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClockList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ListBillingStreamnativeIoV1alpha1TestClock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/testclocks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntent Method for PatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntent

partially update the specified PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PaymentIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntent(ctx context.Context, name string, namespace string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/paymentintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus Method for PatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus

partially update status of the specified PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PaymentIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus(ctx context.Context, name string, namespace string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusExecute(r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/paymentintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1NamespacedPrivateOffer Method for PatchBillingStreamnativeIoV1alpha1NamespacedPrivateOffer

partially update the specified PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PrivateOffer
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedPrivateOffer(ctx context.Context, name string, namespace string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedPrivateOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/privateoffers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus Method for PatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus

partially update status of the specified PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PrivateOffer
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus(ctx context.Context, name string, namespace string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusExecute(r ApiPatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/privateoffers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedProductExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1NamespacedProduct Method for PatchBillingStreamnativeIoV1alpha1NamespacedProduct

partially update the specified Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Product
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedProduct(ctx context.Context, name string, namespace string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedProductExecute(r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/products/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedProductStatusExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1NamespacedProductStatus Method for PatchBillingStreamnativeIoV1alpha1NamespacedProductStatus

partially update status of the specified Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Product
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedProductStatus(ctx context.Context, name string, namespace string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedProductStatusExecute(r ApiPatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedProductStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/products/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1NamespacedSetupIntent Method for PatchBillingStreamnativeIoV1alpha1NamespacedSetupIntent

partially update the specified SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SetupIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedSetupIntent(ctx context.Context, name string, namespace string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedSetupIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/setupintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus Method for PatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus

partially update status of the specified SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SetupIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus(ctx context.Context, name string, namespace string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusExecute(r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/setupintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1NamespacedSubscription Method for PatchBillingStreamnativeIoV1alpha1NamespacedSubscription

partially update the specified Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Subscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedSubscription(ctx context.Context, name string, namespace string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent Method for PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent

partially update the specified SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SubscriptionIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent(ctx context.Context, name string, namespace string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptionintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus Method for PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus

partially update status of the specified SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SubscriptionIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus(ctx context.Context, name string, namespace string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusExecute(r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptionintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus Method for PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus

partially update status of the specified Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Subscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus(ctx context.Context, name string, namespace string) ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusExecute(r ApiPatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1PublicOfferExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1PublicOffer Method for PatchBillingStreamnativeIoV1alpha1PublicOffer

partially update the specified PublicOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PublicOffer
 @return ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1PublicOffer(ctx context.Context, name string) ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1PublicOfferExecute(r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1PublicOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/publicoffers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1PublicOfferStatusExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1PublicOfferStatus Method for PatchBillingStreamnativeIoV1alpha1PublicOfferStatus

partially update status of the specified PublicOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PublicOffer
 @return ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1PublicOfferStatus(ctx context.Context, name string) ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1PublicOfferStatusExecute(r ApiPatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1PublicOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/publicoffers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1TestClockExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1TestClock Method for PatchBillingStreamnativeIoV1alpha1TestClock

partially update the specified TestClock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the TestClock
 @return ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1TestClock(ctx context.Context, name string) ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1TestClockExecute(r ApiPatchBillingStreamnativeIoV1alpha1TestClockRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1TestClock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/testclocks/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	body *map[string]interface{}
	pretty *string
	dryRun *string
	fieldManager *string
	force *bool
}

func (r ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) Body(body map[string]interface{}) ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) Pretty(pretty string) ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) DryRun(dryRun string) ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch, StrategicMergePatch).
func (r ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) FieldManager(fieldManager string) ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

// Force is going to \&quot;force\&quot; Apply requests. It means user will re-acquire conflicting fields owned by other people. Force flag must be unset for non-apply patch requests.
func (r ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) Force(force bool) ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.force = &force
	return r
}

func (r ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	return r.ApiService.PatchBillingStreamnativeIoV1alpha1TestClockStatusExecute(r)
}

/*
PatchBillingStreamnativeIoV1alpha1TestClockStatus Method for PatchBillingStreamnativeIoV1alpha1TestClockStatus

partially update status of the specified TestClock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the TestClock
 @return ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1TestClockStatus(ctx context.Context, name string) ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	return ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
func (a *BillingStreamnativeIoV1alpha1ApiService) PatchBillingStreamnativeIoV1alpha1TestClockStatusExecute(r ApiPatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.PatchBillingStreamnativeIoV1alpha1TestClockStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/testclocks/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/merge-patch+json", "application/strategic-merge-patch+json", "application/apply-patch+yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntent Method for ReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntent

read the specified PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PaymentIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntent(ctx context.Context, name string, namespace string) ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	return ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/paymentintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus Method for ReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus

read status of the specified PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PaymentIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus(ctx context.Context, name string, namespace string) ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	return ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusExecute(r ApiReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/paymentintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1NamespacedPrivateOffer Method for ReadBillingStreamnativeIoV1alpha1NamespacedPrivateOffer

read the specified PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PrivateOffer
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedPrivateOffer(ctx context.Context, name string, namespace string) ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	return ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedPrivateOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/privateoffers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus Method for ReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus

read status of the specified PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PrivateOffer
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus(ctx context.Context, name string, namespace string) ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	return ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusExecute(r ApiReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/privateoffers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1NamespacedProductRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedProductRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedProductRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedProductExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1NamespacedProduct Method for ReadBillingStreamnativeIoV1alpha1NamespacedProduct

read the specified Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Product
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadBillingStreamnativeIoV1alpha1NamespacedProductRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedProduct(ctx context.Context, name string, namespace string) ApiReadBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	return ApiReadBillingStreamnativeIoV1alpha1NamespacedProductRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedProductExecute(r ApiReadBillingStreamnativeIoV1alpha1NamespacedProductRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/products/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedProductStatusExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1NamespacedProductStatus Method for ReadBillingStreamnativeIoV1alpha1NamespacedProductStatus

read status of the specified Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Product
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedProductStatus(ctx context.Context, name string, namespace string) ApiReadBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	return ApiReadBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedProductStatusExecute(r ApiReadBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedProductStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/products/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1NamespacedSetupIntent Method for ReadBillingStreamnativeIoV1alpha1NamespacedSetupIntent

read the specified SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SetupIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedSetupIntent(ctx context.Context, name string, namespace string) ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	return ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedSetupIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/setupintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus Method for ReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus

read status of the specified SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SetupIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus(ctx context.Context, name string, namespace string) ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	return ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusExecute(r ApiReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/setupintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1NamespacedSubscription Method for ReadBillingStreamnativeIoV1alpha1NamespacedSubscription

read the specified Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Subscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedSubscription(ctx context.Context, name string, namespace string) ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	return ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent Method for ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent

read the specified SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SubscriptionIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent(ctx context.Context, name string, namespace string) ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	return ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptionintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus Method for ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus

read status of the specified SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SubscriptionIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus(ctx context.Context, name string, namespace string) ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	return ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusExecute(r ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptionintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus Method for ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus

read status of the specified Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Subscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus(ctx context.Context, name string, namespace string) ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	return ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusExecute(r ApiReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1PublicOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1PublicOfferRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1PublicOfferRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1PublicOfferExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1PublicOffer Method for ReadBillingStreamnativeIoV1alpha1PublicOffer

read the specified PublicOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PublicOffer
 @return ApiReadBillingStreamnativeIoV1alpha1PublicOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1PublicOffer(ctx context.Context, name string) ApiReadBillingStreamnativeIoV1alpha1PublicOfferRequest {
	return ApiReadBillingStreamnativeIoV1alpha1PublicOfferRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1PublicOfferExecute(r ApiReadBillingStreamnativeIoV1alpha1PublicOfferRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1PublicOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/publicoffers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1PublicOfferStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1PublicOfferStatusExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1PublicOfferStatus Method for ReadBillingStreamnativeIoV1alpha1PublicOfferStatus

read status of the specified PublicOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PublicOffer
 @return ApiReadBillingStreamnativeIoV1alpha1PublicOfferStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1PublicOfferStatus(ctx context.Context, name string) ApiReadBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	return ApiReadBillingStreamnativeIoV1alpha1PublicOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1PublicOfferStatusExecute(r ApiReadBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1PublicOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/publicoffers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1TestClockRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1TestClockRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1TestClockRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1TestClockRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1TestClockExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1TestClock Method for ReadBillingStreamnativeIoV1alpha1TestClock

read the specified TestClock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the TestClock
 @return ApiReadBillingStreamnativeIoV1alpha1TestClockRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1TestClock(ctx context.Context, name string) ApiReadBillingStreamnativeIoV1alpha1TestClockRequest {
	return ApiReadBillingStreamnativeIoV1alpha1TestClockRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1TestClockExecute(r ApiReadBillingStreamnativeIoV1alpha1TestClockRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1TestClock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/testclocks/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBillingStreamnativeIoV1alpha1TestClockStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	pretty *string
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReadBillingStreamnativeIoV1alpha1TestClockStatusRequest) Pretty(pretty string) ApiReadBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.pretty = &pretty
	return r
}

func (r ApiReadBillingStreamnativeIoV1alpha1TestClockStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	return r.ApiService.ReadBillingStreamnativeIoV1alpha1TestClockStatusExecute(r)
}

/*
ReadBillingStreamnativeIoV1alpha1TestClockStatus Method for ReadBillingStreamnativeIoV1alpha1TestClockStatus

read status of the specified TestClock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the TestClock
 @return ApiReadBillingStreamnativeIoV1alpha1TestClockStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1TestClockStatus(ctx context.Context, name string) ApiReadBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	return ApiReadBillingStreamnativeIoV1alpha1TestClockStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
func (a *BillingStreamnativeIoV1alpha1ApiService) ReadBillingStreamnativeIoV1alpha1TestClockStatusExecute(r ApiReadBillingStreamnativeIoV1alpha1TestClockStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReadBillingStreamnativeIoV1alpha1TestClockStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/testclocks/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntent Method for ReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntent

replace the specified PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PaymentIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntent(ctx context.Context, name string, namespace string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/paymentintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus Method for ReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus

replace status of the specified PaymentIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PaymentIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus(ctx context.Context, name string, namespace string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusExecute(r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PaymentIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/paymentintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOffer Method for ReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOffer

replace the specified PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PrivateOffer
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOffer(ctx context.Context, name string, namespace string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/privateoffers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus Method for ReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus

replace status of the specified PrivateOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PrivateOffer
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus(ctx context.Context, name string, namespace string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusExecute(r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PrivateOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/privateoffers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedProductExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1NamespacedProduct Method for ReplaceBillingStreamnativeIoV1alpha1NamespacedProduct

replace the specified Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Product
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedProduct(ctx context.Context, name string, namespace string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedProductExecute(r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/products/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatus Method for ReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatus

replace status of the specified Product

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Product
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatus(ctx context.Context, name string, namespace string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusExecute(r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Product
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedProductStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/products/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntent Method for ReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntent

replace the specified SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SetupIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntent(ctx context.Context, name string, namespace string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/setupintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus Method for ReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus

replace status of the specified SetupIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SetupIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus(ctx context.Context, name string, namespace string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusExecute(r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SetupIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/setupintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscription Method for ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscription

replace the specified Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Subscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscription(ctx context.Context, name string, namespace string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent Method for ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent

replace the specified SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SubscriptionIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent(ctx context.Context, name string, namespace string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptionintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus Method for ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus

replace status of the specified SubscriptionIntent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SubscriptionIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus(ctx context.Context, name string, namespace string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusExecute(r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1SubscriptionIntent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptionintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus Method for ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus

replace status of the specified Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Subscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus(ctx context.Context, name string, namespace string) ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusExecute(r ApiReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/namespaces/{namespace}/subscriptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer) ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1PublicOfferExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1PublicOffer Method for ReplaceBillingStreamnativeIoV1alpha1PublicOffer

replace the specified PublicOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PublicOffer
 @return ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1PublicOffer(ctx context.Context, name string) ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1PublicOfferExecute(r ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1PublicOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/publicoffers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer) ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1PublicOfferStatus Method for ReplaceBillingStreamnativeIoV1alpha1PublicOfferStatus

replace status of the specified PublicOffer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PublicOffer
 @return ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1PublicOfferStatus(ctx context.Context, name string) ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusExecute(r ApiReplaceBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1PublicOffer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1PublicOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/publicoffers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock) ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1TestClockExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1TestClock Method for ReplaceBillingStreamnativeIoV1alpha1TestClock

replace the specified TestClock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the TestClock
 @return ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1TestClock(ctx context.Context, name string) ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1TestClockExecute(r ApiReplaceBillingStreamnativeIoV1alpha1TestClockRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1TestClock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/testclocks/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	body *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
	pretty *string
	dryRun *string
	fieldManager *string
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest) Body(body ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock) ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.body = &body
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest) Pretty(pretty string) ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.pretty = &pretty
	return r
}

// When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
func (r ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest) DryRun(dryRun string) ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.dryRun = &dryRun
	return r
}

// fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
func (r ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest) FieldManager(fieldManager string) ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.fieldManager = &fieldManager
	return r
}

func (r ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest) Execute() (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	return r.ApiService.ReplaceBillingStreamnativeIoV1alpha1TestClockStatusExecute(r)
}

/*
ReplaceBillingStreamnativeIoV1alpha1TestClockStatus Method for ReplaceBillingStreamnativeIoV1alpha1TestClockStatus

replace status of the specified TestClock

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the TestClock
 @return ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1TestClockStatus(ctx context.Context, name string) ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	return ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
func (a *BillingStreamnativeIoV1alpha1ApiService) ReplaceBillingStreamnativeIoV1alpha1TestClockStatusExecute(r ApiReplaceBillingStreamnativeIoV1alpha1TestClockStatusRequest) (*ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComGithubStreamnativeCloudApiServerPkgApisBillingV1alpha1TestClock
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.ReplaceBillingStreamnativeIoV1alpha1TestClockStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/testclocks/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.dryRun != nil {
		localVarQueryParams.Add("dryRun", parameterToString(*r.dryRun, ""))
	}
	if r.fieldManager != nil {
		localVarQueryParams.Add("fieldManager", parameterToString(*r.fieldManager, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntent Method for WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntent

watch changes to an object of kind PaymentIntent. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PaymentIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntent(ctx context.Context, name string, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/paymentintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentList Method for WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentList

watch individual changes to a list of PaymentIntent. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentList(ctx context.Context, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/paymentintents"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus Method for WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus

watch changes to status of an object of kind PaymentIntent. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PaymentIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus(ctx context.Context, name string, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedPaymentIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/paymentintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOffer Method for WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOffer

watch changes to an object of kind PrivateOffer. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PrivateOffer
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOffer(ctx context.Context, name string, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/privateoffers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferList Method for WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferList

watch individual changes to a list of PrivateOffer. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferList(ctx context.Context, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/privateoffers"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus Method for WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus

watch changes to status of an object of kind PrivateOffer. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PrivateOffer
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus(ctx context.Context, name string, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedPrivateOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/privateoffers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedProductExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedProduct Method for WatchBillingStreamnativeIoV1alpha1NamespacedProduct

watch changes to an object of kind Product. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Product
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedProduct(ctx context.Context, name string, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedProductExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/products/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedProductListExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedProductList Method for WatchBillingStreamnativeIoV1alpha1NamespacedProductList

watch individual changes to a list of Product. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedProductList(ctx context.Context, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedProductListExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedProductList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/products"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedProductStatusExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedProductStatus Method for WatchBillingStreamnativeIoV1alpha1NamespacedProductStatus

watch changes to status of an object of kind Product. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Product
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedProductStatus(ctx context.Context, name string, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedProductStatusExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedProductStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedProductStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/products/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntent Method for WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntent

watch changes to an object of kind SetupIntent. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SetupIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntent(ctx context.Context, name string, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/setupintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentList Method for WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentList

watch individual changes to a list of SetupIntent. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentList(ctx context.Context, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/setupintents"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus Method for WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus

watch changes to status of an object of kind SetupIntent. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SetupIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus(ctx context.Context, name string, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSetupIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/setupintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedSubscription Method for WatchBillingStreamnativeIoV1alpha1NamespacedSubscription

watch changes to an object of kind Subscription. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Subscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSubscription(ctx context.Context, name string, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSubscription")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/subscriptions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent Method for WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent

watch changes to an object of kind SubscriptionIntent. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SubscriptionIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent(ctx context.Context, name string, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/subscriptionintents/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentList Method for WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentList

watch individual changes to a list of SubscriptionIntent. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentList(ctx context.Context, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/subscriptionintents"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus Method for WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus

watch changes to status of an object of kind SubscriptionIntent. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the SubscriptionIntent
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus(ctx context.Context, name string, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionIntentStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/subscriptionintents/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionList Method for WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionList

watch individual changes to a list of Subscription. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionList(ctx context.Context, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest{
		ApiService: a,
		ctx: ctx,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/subscriptions"
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	namespace string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus Method for WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus

watch changes to status of an object of kind Subscription. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the Subscription
 @param namespace object name and auth scope, such as for teams and projects
 @return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus(ctx context.Context, name string, namespace string) ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		namespace: namespace,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusExecute(r ApiWatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1NamespacedSubscriptionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/namespaces/{namespace}/subscriptions/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"namespace"+"}", url.PathEscape(parameterToString(r.namespace, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespaces Method for WatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespaces

watch individual changes to a list of PaymentIntent. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespaces(ctx context.Context) ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesExecute(r ApiWatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1PaymentIntentListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/paymentintents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespaces Method for WatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespaces

watch individual changes to a list of PrivateOffer. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespaces(ctx context.Context) ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesExecute(r ApiWatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1PrivateOfferListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/privateoffers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1ProductListForAllNamespaces Method for WatchBillingStreamnativeIoV1alpha1ProductListForAllNamespaces

watch individual changes to a list of Product. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1ProductListForAllNamespaces(ctx context.Context) ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesExecute(r ApiWatchBillingStreamnativeIoV1alpha1ProductListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1ProductListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1PublicOfferExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1PublicOffer Method for WatchBillingStreamnativeIoV1alpha1PublicOffer

watch changes to an object of kind PublicOffer. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PublicOffer
 @return ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1PublicOffer(ctx context.Context, name string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1PublicOfferExecute(r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1PublicOffer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/publicoffers/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1PublicOfferListExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1PublicOfferList Method for WatchBillingStreamnativeIoV1alpha1PublicOfferList

watch individual changes to a list of PublicOffer. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1PublicOfferList(ctx context.Context) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1PublicOfferListExecute(r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1PublicOfferList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/publicoffers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1PublicOfferStatusExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1PublicOfferStatus Method for WatchBillingStreamnativeIoV1alpha1PublicOfferStatus

watch changes to status of an object of kind PublicOffer. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the PublicOffer
 @return ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1PublicOfferStatus(ctx context.Context, name string) ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1PublicOfferStatusExecute(r ApiWatchBillingStreamnativeIoV1alpha1PublicOfferStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1PublicOfferStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/publicoffers/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespaces Method for WatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespaces

watch individual changes to a list of SetupIntent. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespaces(ctx context.Context) ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesExecute(r ApiWatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1SetupIntentListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/setupintents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespaces Method for WatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespaces

watch individual changes to a list of SubscriptionIntent. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespaces(ctx context.Context) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesExecute(r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1SubscriptionIntentListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/subscriptionintents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespaces Method for WatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespaces

watch individual changes to a list of Subscription. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespaces(ctx context.Context) ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesExecute(r ApiWatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespacesRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1SubscriptionListForAllNamespaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1TestClockExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1TestClock Method for WatchBillingStreamnativeIoV1alpha1TestClock

watch changes to an object of kind TestClock. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the TestClock
 @return ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1TestClock(ctx context.Context, name string) ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1TestClockExecute(r ApiWatchBillingStreamnativeIoV1alpha1TestClockRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1TestClock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/testclocks/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1TestClockListExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1TestClockList Method for WatchBillingStreamnativeIoV1alpha1TestClockList

watch individual changes to a list of TestClock. deprecated: use the 'watch' parameter with a list operation instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1TestClockList(ctx context.Context) ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1TestClockListExecute(r ApiWatchBillingStreamnativeIoV1alpha1TestClockListRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1TestClockList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/testclocks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest struct {
	ctx context.Context
	ApiService *BillingStreamnativeIoV1alpha1ApiService
	name string
	allowWatchBookmarks *bool
	continue_ *string
	fieldSelector *string
	labelSelector *string
	limit *int32
	pretty *string
	resourceVersion *string
	resourceVersionMatch *string
	timeoutSeconds *int32
	watch *bool
}

// allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) AllowWatchBookmarks(allowWatchBookmarks bool) ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.allowWatchBookmarks = &allowWatchBookmarks
	return r
}

// The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) Continue_(continue_ string) ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.continue_ = &continue_
	return r
}

// A selector to restrict the list of returned objects by their fields. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) FieldSelector(fieldSelector string) ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.fieldSelector = &fieldSelector
	return r
}

// A selector to restrict the list of returned objects by their labels. Defaults to everything.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) LabelSelector(labelSelector string) ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.labelSelector = &labelSelector
	return r
}

// limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) Limit(limit int32) ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.limit = &limit
	return r
}

// If &#39;true&#39;, then the output is pretty printed.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) Pretty(pretty string) ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.pretty = &pretty
	return r
}

// resourceVersion sets a constraint on what resource versions a request may be served from. See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) ResourceVersion(resourceVersion string) ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.resourceVersion = &resourceVersion
	return r
}

// resourceVersionMatch determines how resourceVersion is applied to list calls. It is highly recommended that resourceVersionMatch be set for list calls where resourceVersion is set See https://kubernetes.io/docs/reference/using-api/api-concepts/#resource-versions for details.  Defaults to unset
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) ResourceVersionMatch(resourceVersionMatch string) ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.resourceVersionMatch = &resourceVersionMatch
	return r
}

// Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) TimeoutSeconds(timeoutSeconds int32) ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.timeoutSeconds = &timeoutSeconds
	return r
}

// Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) Watch(watch bool) ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	r.watch = &watch
	return r
}

func (r ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) Execute() (*V1WatchEvent, *http.Response, error) {
	return r.ApiService.WatchBillingStreamnativeIoV1alpha1TestClockStatusExecute(r)
}

/*
WatchBillingStreamnativeIoV1alpha1TestClockStatus Method for WatchBillingStreamnativeIoV1alpha1TestClockStatus

watch changes to status of an object of kind TestClock. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of the TestClock
 @return ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest
*/
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1TestClockStatus(ctx context.Context, name string) ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest {
	return ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V1WatchEvent
func (a *BillingStreamnativeIoV1alpha1ApiService) WatchBillingStreamnativeIoV1alpha1TestClockStatusExecute(r ApiWatchBillingStreamnativeIoV1alpha1TestClockStatusRequest) (*V1WatchEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1WatchEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingStreamnativeIoV1alpha1ApiService.WatchBillingStreamnativeIoV1alpha1TestClockStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/apis/billing.streamnative.io/v1alpha1/watch/testclocks/{name}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allowWatchBookmarks != nil {
		localVarQueryParams.Add("allowWatchBookmarks", parameterToString(*r.allowWatchBookmarks, ""))
	}
	if r.continue_ != nil {
		localVarQueryParams.Add("continue", parameterToString(*r.continue_, ""))
	}
	if r.fieldSelector != nil {
		localVarQueryParams.Add("fieldSelector", parameterToString(*r.fieldSelector, ""))
	}
	if r.labelSelector != nil {
		localVarQueryParams.Add("labelSelector", parameterToString(*r.labelSelector, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.pretty != nil {
		localVarQueryParams.Add("pretty", parameterToString(*r.pretty, ""))
	}
	if r.resourceVersion != nil {
		localVarQueryParams.Add("resourceVersion", parameterToString(*r.resourceVersion, ""))
	}
	if r.resourceVersionMatch != nil {
		localVarQueryParams.Add("resourceVersionMatch", parameterToString(*r.resourceVersionMatch, ""))
	}
	if r.timeoutSeconds != nil {
		localVarQueryParams.Add("timeoutSeconds", parameterToString(*r.timeoutSeconds, ""))
	}
	if r.watch != nil {
		localVarQueryParams.Add("watch", parameterToString(*r.watch, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/yaml", "application/vnd.kubernetes.protobuf", "application/json;stream=watch", "application/vnd.kubernetes.protobuf;stream=watch"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
